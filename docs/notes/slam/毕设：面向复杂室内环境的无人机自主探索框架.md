## 因子图后端优化

### 因子图的基本思想

在 SLAM  中，**因子图（Factor Graph）** 是描述优化问题结构的图模型：

- **节点（Variables）**：表示待估计的状态变量，例如：
    - 位姿（camera pose）$\mathbf{T}_i = [\mathbf{R}_i, \mathbf{t}_i]$
    - 地标（landmark）$\mathbf{p}_j$
    - IMU 偏置（bias）$\mathbf{b}_i$
    - 对象语义特征（object feature）$\mathbf{o}_m$
        
- **因子（Factors）**：表示测量约束 $f_k(X_k) - z_k$，例如：
    - 相机观测因子（视觉重投影误差）
    - IMU 因子（惯性积分误差）
    - 语义约束因子（语义一致性误差）

最终的目标是：
$$X^* = \underset{X}{\operatorname{argmin}} \sum_{k} \left\| f_k(X_k) - z_k \right\|_{\Sigma_k}^2$$

---
### 联合优化的总体流程

#### 步骤 1：状态定义（Variables）

定义状态量集合 $X$：
$$X = \{\mathbf{T}_1, \mathbf{T}_2, \ldots, \mathbf{T}_N, \mathbf{p}_1, \mathbf{p}_2, \ldots, \mathbf{p}_M, \mathbf{b}_1, \mathbf{o}_1, \ldots\}$$
其中：
- $\mathbf{T}_i$：第 i 帧相机的位姿（SE(3)）
- $\mathbf{p}_j$：第 j 个路标点（地图点）
- $\mathbf{b}_i$​：IMU 零偏（bias）
- $\mathbf{o}_m$​：语义对象特征（如检测框、语义中心）
---
#### 步骤 2：构建因子（Measurement Factors）

我们根据不同传感器建立不同类型的因子，每个因子对应一个测量模型 $f_k(X_k)$)。
##### (1) 视觉因子（Reprojection Factor）

- 测量：图像中像素坐标 $z_{ij}$
- 模型：
  $$f_{\text{vision}}(X_k) = \pi(\mathbf{T}_i^{-1}\mathbf{p}_j)$$

    - 其中 $\pi(\cdot)$ 是相机投影模型。
- 误差：
    $$e_{ij}^{\text{vision}} = f_{\text{vision}}(X_k) - z_{ij}$$​
- 物理含义：当前估计的位姿和路标能否在像素平面上**重投影到真实观测点**。
---
##### (2) IMU 因子（Preintegration Factor）

- 测量：IMU 在两帧之间的加速度、角速度读数。
- 模型（经过预积分）：
$$f_{\text{imu}}(X_k) = \text{Preintegrate}(\mathbf{b}_i, \Delta t)$$
    
    - 预测相邻两帧之间的运动。
- 误差项：
    $$e_{ij}^{\text{imu}} = \text{Log}\left( (\mathbf{T}_i^{-1}\mathbf{T}_j) \ominus f_{\text{imu}}(X_k) \right)$$
- 物理含义：当前**位姿估计与IMU测得的运动变化**是否一致。
---
##### (3) 语义因子（Semantic Factor）

语义信息来自语义分割或目标检测模型，约束地图中某些结构（如墙面、行人、车辆）的几何一致性。

例如：
- 语义分割提供每个像素的类别概率；
- 检测框提供语义对象的空间约束。
    

可定义：
$$f_{\text{sem}}(X_k) = g(\mathbf{T}_i, \mathbf{o}_m)$$
表示当前相机姿态与对象位置之间的**几何语义一致性预测**。
- 误差项：
	$$e_{im}^{\text{sem}} = f_{\text{sem}}(X_k) - z_{im}$$
    - 其中$z_{im}$ 是语义观测（例如物体类别、像素位置或mask）。

- 物理含义：当前位姿估计下，预测的物体投影应与语义分割结果匹配。
---
#### 步骤 3：组合代价函数

将所有误差项加权求和：
$$J(X) = \sum_{(i,j)\in \mathcal{C}} \| e_{ij}^{\text{vision}} \|_{\Sigma_v}^2 + \sum_{(i,j)\in \mathcal{I}} \| e_{ij}^{\text{imu}} \|_{\Sigma_i}^2 + \sum_{(i,m)\in \mathcal{S}} \| e_{im}^{\text{sem}} \|_{\Sigma_s}^2$$
---
#### 步骤 4：线性化与迭代优化

由于$f_k(X_k$ 非线性，需线性化后使用 **高斯牛顿 (Gauss-Newton)** 或 **LM (Levenberg–Marquardt)** 优化。

1. 线性化：
    $$f_k(X_k + \delta X_k) \approx f_k(X_k) + J_k \delta X_k$$​
2. 构建线性方程：
    $$(J^T \Sigma^{-1} J)\delta X = -J^T \Sigma^{-1} e$$
3. 求解增量$\delta X$，更新状态：
    $$X \leftarrow X \oplus \delta X$$
4. 重复迭代直至收敛。
---
#### 步骤 5：结果与意义

优化后得到：
$$X^* = \{\mathbf{T}_i^*, \mathbf{p}_j^*, \mathbf{b}_i^*, \mathbf{o}_m^*\}$$
即最优估计的相机轨迹、地图点位置、IMU偏置以及语义对象位置。

---
## 滑动窗口优化原理

### 1. 问题的提出：全局优化的局限性

在视觉-惯性 SLAM（VIO）或大规模 SLAM 系统中，全局束调整（Full Bundle Adjustment, FBA）旨在优化所有历史状态（位姿、路标、IMU 偏置等），如公式 (1) 所示：

$$
X^* = \underset{X}{\operatorname{argmin}} \sum_{k} \left\| f_k(X_k) - z_k \right\|_{\Sigma_k}^2
$$

然而，随着时间 $t \rightarrow \infty$，状态向量 \( X \) 的维度是 **无界（unbounded）** 的。这导致非线性最小二乘问题中的 Hessian（或信息矩阵）

$$
H = J^T \Sigma^{-1} J
$$

的规模无限增长，实时求解的计算复杂度急剧上升，无法满足实时性要求。


---

### 2. 解决方案：基于滑动窗口的有限状态优化

为保证计算量的有界性（bounded complexity），提出 **滑动窗口优化（Sliding Window Optimization）**。

其核心思想是：  
在任意时刻 $t$，仅对一个固定大小（Size $N$）的“窗口”内的状态子集 $X_w$ 进行优化。

$$
X_w = \{\mathbf{T}_{t-N+1}, \ldots, \mathbf{T}_t, \mathbf{p}_j, \ldots\}
$$

其中包含最近的 $N$ 帧位姿以及它们所观测到的路标。

---

### 3. 核心原理：边缘化（Marginalization）

当新的关键帧 $\mathbf{T}_{t+1}$ 进入窗口时，最老的关键帧 $\mathbf{T}_{t-N+1}$会被移出窗口。

**如果简单丢弃这些状态及其因子，会导致：**

- 信息损失
- 可观性（observability）破坏
- 系统快速漂移

因此需要 **边缘化**：  
把 $\mathbf{T}_{t-N+1}$ 中包含的信息“转移”给窗口内剩余变量，而不是丢弃它。

---

### 4. 数学实现：舒尔补（Schur Complement）

将待优化的状态分成两部分：

- $X_m$：待边缘化的状态
- $X_r$：保留在窗口的状态

线性化后的系统：

$$
\begin{bmatrix}
H_{mm} & H_{mr} \\
H_{rm} & H_{rr}
\end{bmatrix}
\begin{bmatrix}
\delta X_m \\
\delta X_r
\end{bmatrix}
=
\begin{bmatrix}
b_m \\
b_r
\end{bmatrix}
$$

使用舒尔补消去 $\delta X_m$：

$$
(H_{rr} - H_{rm} H_{mm}^{-1} H_{mr}) \, \delta X_r 
= 
(b_r - H_{rm} H_{mm}^{-1} b_m)
$$

定义：

$$
H' = H_{rr} - H_{rm} H_{mm}^{-1} H_{mr}
$$

$$
b' = b_r - H_{rm} H_{mm}^{-1} b_m
$$

新系统 $H' \delta X_r = b'$ 与原系统物理等价，但变量 $X_m$已被移除。

---

### 5. 形成先验因子（Prior Factor）

以上得到的 $H'$ 和 $b'$ 构成一个新的 **先验因子（Prior Factor）**。

加入到窗口代价函数中：

$$
J(X_w) = 
\sum_{k \in \text{Window}} \| e_k \|_{\Sigma_k}^2
+
\| e_{\text{prior}} \|_{\Sigma_{\text{prior}}}^2
$$

其中 $e_{\text{prior}}$ 由 $H'$ 和 $b'$ 构成，用来保留已被边缘化历史状态对当前的约束。

---

### 6. 总结与权衡

滑动窗口优化通过边缘化，将无限增长的全局优化问题，转化为一个 **计算复杂度有界、可实时** 的优化过程。

### 优点
- 保证系统实时性
- 适用于 VIO、前端紧耦合 SLAM 等高频优化场景  

### 缺点（关键）
- **边缘化是一种不可逆近似**
- 会固定被边缘化变量的线性化点
- 若线性化点不准确，将导致系统 **不一致性（Inconsistency）**

这也是为什么很多现代 SLAM（如 VINS-Mono、OKVIS、GVINS）需要 carefully designed marginalization 策略。

---
## 探索的过程

### 3.1 总体探索循环（伪代码）
```python
Initialize SLAM, hierarchical maps

while True:

	Update sensor frames -> SLAM update -> update metric-semantic submap
	Update topological map (cluster / split submaps)
	
	# 上层决策：选择下一个目标 submap 或 viewpoint cluster
	target = TopologicalSelector(topology, frontier_set, battery, time)
	if target is None:
		if ShouldStop(): break
		else: continue
	
	# 下层执行：到目标并在局部维护可观测性
	success = LocalExecutionController(target)
	if not success:
		Mark target as failed / increase cost in topology
		continue

	# 闭环检测：被动或主动触发
	LoopClosureManager.check_and_execute()

	# 后处理：优化位姿图、更新 map consistency
	if pose_graph_needs_optimization:
		OptimizePoseGraph()
	
end
```

---
### 3.2 上层：拓扑选择器（TopologicalSelector）

**输入：** 拓扑图、未访问/部分访问 submap 列表、每个 submap 的预期信息增益、任务级约束（剩余电量、时间）、优先级策略。

**输出：** 目标 submap 或视点簇。

策略示例：

- 计算每个 candidate 的效用： `U = IG / (travel_cost + λ * uncertainty)`。
    
- IG（信息增益）可由 submap 的 frontier 面积、语义未见区域、及预期观察的语义多样性合成。
    
- 选择使 U 最大的 candidate。如果最大 U < 阈值，则不再继续高层探索。
---
### 3.3 下层：局部执行控制（LocalExecutionController）

职责：从当前位姿到上层指定的局部目标视点集合，执行局部路径规划（避障）、在路径上维护特征观测质量（visibility preserving），并在到达后执行局部观测策略（sweep、视角变换）。

局部轨迹优化代价函数示例：
$$J(\xi)=\alpha J_{collision}(\xi)+\beta J_{smooth}(\xi)+\gamma J_{visibility}(\xi)+\delta J_{energy}(\xi)$$

- $J_{collision}$：最小化与障碍物距离的负值；
    
- $J_{smooth}$：轨迹平滑项（加速度、角加速度成本）；
    
- $J_{visibility}$：保证关键语义/几何特征在可视锥内，或保证局部特征数 >= N_min；
    
- $J_{energy}$：估计能耗。
    

规划器选择：

- 先用全局可到达性检查（A* / D* on 2D grid 或 visibility graph）；
    
- 局部用采样/梯度优化 (RRT*/CHOMP/TrajOpt) 优化上面代价函数。
    

到达目标后：执行视角扫查（若IG高，环绕或做小角度转动以获取更多语义信息）。

---
### 3.4 前沿检测（Frontier Detection）

在每个 submap 内做经典的 frontier 检测（已知 free 空间边界与未知空间的接壤），用于估计 IG 与生成 candidate viewpoints。

加速技巧：

- 在分层地图上仅对 Level1 中**未完全覆盖的 submap 做 frontier 检测，避免全图更新成本**。
- 使用局部 BFS/迭代膨胀以边缘优先检测。
---
### 3.5 视点生成与信息增益估计

每个 frontier 点生成若干候选视点（不同高度/朝向）。对每个候选视点用快速近似（ray-casting on local occupancy grid + semantic prior）估计观测到的新语义/几何信息量。

---
## Metric-Semantic SLAM

### 分层体素地图

1. **分层地图表示 (Hierarchical Map Representation):**
    
    - **局部度量-语义地图 (Local Metric-Semantic Grid, L-MSG):** 一个以UAV为中心的、高分辨率的体素网格（Voxel Grid）。其主要职责是**实时避障**与**局部感知**。
        
    - **全局度量-语义地图 (Global Metric-Semantic Grid, G-MSG):** 一个持久化的、全局坐标系下的分层（如Octree）体素地图。其主要职责是**长期存储**、**全局规划**与**闭环检测数据库**。
        
2. **双重状态估计 (Dual State Estimation):**
    
    - **VIO 前端 (VIO Front-end):** 提供**高频、实时但存在漂移**的里程计（Odometry）姿态 $T_{\text{VIO}}$。
        
    - **SLAM 后端 (SLAM Back-end):** 一个基于因子图的优化器，用于优化关键帧（Keyframe）姿态 $T_{\text{SLAM}}$，实现**低频、高精度、全局一致**的轨迹估计。
        

#### 分层地图的构建与双重更新

该框架的精髓在于其双重更新机制，它**解耦（decouples）**了实时避障与全局一致性的更新需求。

- 局部地图更新（VIO驱动）：
    
    L-MSG 仅由 VIO 前端的实时姿态 $T_{\text{VIO}}$ 更新。
    
    - **目的：** 保证最低的延迟（low-latency）。
        
    - **流程：** 传感器数据（深度、语义）根据 $T_{\text{VIO}}$ 被立即投影（project）和融合（fuse）到 L-MSG 中。这保证了无人机“脚下”的地图始终是最新（up-to-date）的，即使它会随VIO漂移。
        
- 全局地图更新（SLAM驱动）：
    
    G-MSG 仅由 SLAM 后端优化后的姿态 $T_{\text{SLAM}}$ 更新。
    
    - **目的：** 保证全局一致性。
        
    - **流程：** 当后端（例如，通过滑动窗口或闭环）优化了关键帧 $KF_i$ 的姿态后，系统才使用这个**修正过**的姿态 $T_{\text{SLAM}, i}$，将 $KF_i$ 携带的度量与语义信息（存储在其缓存中）融合到 G-MSG 中。
        

此策略确保了 G-MSG 不会被 VIO 的漂移所“污染”，始终代表了系统对世界的“最佳信念”（best belief）。

---
### 基于语义子图的主动闭环

该流程周期性运行，用于**主动**寻找并确认闭环，而非被动等待。

- **阶段 1：查询子图生成 (Query Subgraph Generation)**
    
    - 无人机首先从其**局部语义地图（L-MSG）**中，提取当前视野内所有可观测到的、高置信度的语义对象。
        
    - 这些对象及其**相对空间关系**（如距离、方位）被构建为一个 **“查询-属性关系图” (Query-Attributed Relational Graph, Q-ARG)**。
        
    - _示例：_ 节点 {`冰箱`, `微波炉`}，边 {`距离=1.5m`, `方位=30°`}。
        
- **阶段 2：候选匹配 (Candidate Matching)**
    
    - 系统使用这个 Q-ARG，在**全局语义地图（G-MSG）** 的数据库中进行**子图匹配（Subgraph Matching）** 查询。
        
    - _查询：_ “在 G-MSG 中，是否存在一个历史“场景”，其包含的语义对象和空间关系与 Q-ARG 同构（isomorphic）？”
        
    - 匹配成功将返回一个或多个**候选（Candidate）**。
        
- **阶段 3：生成候选“子图-观测点对”**
    
    - 每个候选匹配不仅包含一个 **“历史-语义子图” (H-ARG)** ，还包含了当时观测到该 H-ARG 的**历史关键帧（Historical Keyframe）**  $KF_{\text{hist}}$。
        
    - 系统因此生成了一组 `{Q-ARG, H-ARG, KF_hist}` 对，即 **“语义闭环子图-观测点对”** 。
        
- **阶段 4：信息增益评估与决策 (IG-Based Decision)**
    
    - 对于每个候选 $KF_{\text{hist}}$，系统并不立即执行闭环，而是在因子图中添加虚拟因子。
        - 它**临时**在后端因子图中添加一个**虚拟闭环因子 (Virtual LC Factor)**，连接当前帧 $KF_{\text{now}}$ 和 $KF_{\text{hist}}$。
        - 通过计算**协方差矩阵迹（Trace）的预期减少量**来量化信息增益 $IG$：
        $$ \\ IG = tr(\Sigma\_{\text{prior}}) - tr(\Sigma\_{\text{posterior}})$$
	    - 系统权衡 $IG$（收益）与前往 $KF_{\text{hist}}$ 附近所需**路径成本 $C$（成本）**，选择效用（Utility）最高的候选，并主动规划路径执行闭环。