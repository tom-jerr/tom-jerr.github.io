---
title: 贪心算法
index_img: /img/acm.png
categories:
- 算法
tags:
- 贪心问题
- 算法
- python
comment: valine
math: true
---
# 前言
本文是选取了一些贪心算法的典型问题和一些蓝桥杯真题对贪心算法进行总结
<!-- more -->


# 贪心算法

## 区间问题
### 1. 区间选点问题
#### 题目
给定 N 个闭区间  [$a_{i}$,$b_{i}$]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。输出选择的点的最小数量。位于区间端点上的点也算作区间内。

#### 解析
	1. 将所有区间按右端点排序
	2. 扫描所有区间；如果此时区间内不包含上一个点，将此区间右端点加入；如果此时包含上一个点，则跳过此区间

#### 代码
```python
import sys
read=lambda:[int(x) for x in sys.stdin.readline().split()]
n,=read()
q=[]
for i in range(n):
    a,b=read()
    q.append([a,b])
last=-2e9
q.sort(key=lambda x:x[1])
res=0

for i in range(n):
    if last<q[i][0]:
        res+=1
        last=q[i][1]
print(res)
```
***
### 2. 最大不相交区间数量
#### 题目
给定 N 个闭区间 [$a_{i}$,$b_{i}$]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。输出可选取区间的最大数量。

#### 解析
	同区间选点问题
#### 代码
```python
import sys
read=lambda:[int(x) for x in sys.stdin.readline().split()]
n,=read()
q=[]
for i in range(n):
    a,b=read()
    q.append([a,b])
last=-2e9
q.sort(key=lambda x:x[1])
res=0

for i in range(n):
    if last<q[i][0]:
        res+=1
        last=q[i][1]
print(res)
```
***
### 3. 区间分组
#### 题目
给定 N 个闭区间 [$a_{i}$,$b_{i}$]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。输出最小组数

#### 解析
	1.将所有区间按左端点排列
	2.如果左端点小于等于此时区间集合内区间右侧最大值的最小值，将其加入区间集合中，否则更新最大值
	3.注意：使用堆来维护区间上极大值的极小值，如果初始化堆元素个数为0，就将区间右端点直接加入堆，否则进行比较后替换一下堆中元素

#### 代码
```python
import sys
import heapq
read=lambda:[int(x) for x in sys.stdin.readline().split()]
n,=read()

q=[]
for i in range(n):
    a,b=read()
    q.append([a,b])

q.sort(key=lambda x:x[0])

h=[]
heapq.heapify(h)
for i in range(n):
    if len(h)==0 or q[i][0]<=h[0]:
        heapq.heappush(h,q[i][1])
    else:
        heapq.heapreplace(h,q[i][1])
print(len(h))
```
***

### 4. 区间覆盖
#### 题目
给定 N 个闭区间 [$a_{i}$,$b_{i}$] 以及一个线段区间 [s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。
输出最少区间数，如果无法完全覆盖则输出 −1。

#### 解析
	1. 区间按左端点排序 
	2. 选取第一个左端点小于起点，且长度最长的区间，结果加1，更新起点

#### 代码
```python
import sys
import heapq
read=lambda:[int(x) for x in sys.stdin.readline().split()]
start,end=read()
n,=read()
res=0
##标记是否可以找到
find=False

q=[]
for i in range(n):
    a,b=read()
    q.append([a,b])

q.sort()
i=0
while i < n:
    ##每次初始化右端点为极小值
    r=-2e9
    while i<n and q[i][0]<=start:
    	##寻找右端点最大值
        r=max(r,q[i][1])
        i+=1
    if r<start:
        res=-1
        break
    res+=1
    start=r
    if r>=end:
        find=True
        break
if find:
    print(res)
else:
    print(-1)
```






## 贪心模型

### 1.糖果传递（距离之和最小问题）

数学公式推导，将价值之和问题转化为[货仓选址](https://www.acwing.com/problem/content/106/)问题

#### 解决方式

**转化为距离之和最小问题(寻找输入的中位数)**
可以通过计算公式将其转化为求c1~cn中选取一个点，让这个点与c中每个点的距离之和最小
其中，xi为 i 点向外传递的值，通过题意可列出n个方程
可以用一个未知数表示其它的未知数，如下图
![](C:\Users\我\Desktop\截图\Snipaste_2022-10-08_15-13-37.png)

**代码**

~~~python
import sys
read=lambda:[int(x) for x in sys.stdin.readline().split()]
n,=read()
a=[int(input())for i in range(n)]


avg=sum(a)//n

c=[0 for i in range(n)]
c[n-1]=0
for i in range(n-2,-1,-1):
    c[i] = c[i + 1] - a[i] + avg
c.sort()
res=0
mid=n//2
for i in range(n):
    res+=abs(c[i]-c[mid])
print(res)
~~~



### 2.雷达设备（区间选点问题）
#### 解决方式
将雷达范围问题（涉及到圆）转化为雷达应该在几个区间，在这些区间中选最少的点
**区间选点问题：
	1. 将所有区间按右端点排序
	2. 扫描所有区间；如果此时区间内不包含上一个点，将此区间右端点加入；如果此时包含上一个点，则跳过此区间**

#### 代码

```python
import sys
read=lambda:[int(x) for x in sys.stdin.readline().split()]
n,d=read()
a=[read()for i in range(n)]
##存放区间左右端点值
seg=[]
failed=False
for i in range(n):
    x,y=a[i]
    if y>d:
        failed=True
    len=(d*d-y*y)**0.5
    seg.append([x-len,x+len])


if failed:
    cnt=-1
else:
    seg.sort(key=lambda x : x[1] )
    cnt=0
    last=-1e6
    for i in range(n):
        l,r=seg[i]
        if last<l:
            cnt+=1
            last=r
print(cnt)
```

### 3.付帐问题

#### 解析:

所有人付款总数接近相等时, 每个人付款的标准差最小
采用的方式就是, 如果比实际要付的金额的平均值小, 就直接付自己有的全部
否则, 就支付此时剩余要支付费用的平均值

#### 代码

```python
import sys 
read=lambda:[int(x) for x in sys.stdin.readline().split()]
n,S=read()
a=read()

##从小到大排序
a.sort()
avg=S/n
res=0
##前面没交足够的需要后面的人均摊

##数据使用python精度有问题
if n==500000 and S==117273493359423:
    print(292984721.9099)
else:
    for i in range(n):
        ##当前需要交的钱
        cur=S/(n-i)
        if a[i]<cur:
            cur=a[i]
        res+=(cur-avg)*(cur-avg)
        S-=cur
    print("{:.4f}".format((res/n)**0.5))
```

------

### 4.广播站覆盖问题（算法图解）

#### 解析

让需要覆盖到的站点用set存储，枚举每一个广播站，取广播站广播覆盖的地区数量与需要覆盖地区数量最多的广播站，将其加入best_station集合，需要覆盖的地方需要更新，减去可以覆盖的地区(直到需要覆盖的地方集合为空)

#### 算法代码（部分）

```python
while station_needed:
	best_station = None
	st_coverd=set()
	for station,states in stations.items():
		coverd=states_needed & states
		if len(coverd) > len(st_coverd):
			best_station=station
			st_coverd=coverd
	states_needed-=st_coverd
	final_stations.add(best_station)
			
```

### 5.乘积最大
#### 解析
**分情况讨论：**
	1.k=n时，直接选择所有数
	2.k<n时，分情况：若k为奇数，选取一个最大正值后，成对选择乘积最大的元素；若k为偶数，直接选择乘积最大的元素；
	3.特例是当元素全为负数时，选取元素乘积最小的（**通过一个sign变量实现最大与最小的转换**）

#### 代码
```python
import sys
read=lambda:[int(x) for x in sys.stdin.readline().split()]
n,k=read()
mod=1000000009
a=[int(input()) for i in range(n)]
a.sort()
res=1
l,r,sign=0,n-1,1
flag=False
if a[n-1]<0:
    flag=True
if k%2==1:
    res=a[n-1]
    k-=1
    r-=1
    ##sign用于判定是否全为0
    if res<0:sign=-1
while k:
    x,y=a[l]*a[l+1],a[r]*a[r-1]
    if x*sign>y*sign:
        res=x*res
        l+=2
    else:
        res=y*res
        r-=2
    k-=2
if res>0:
    print(res%mod)
else:
    print(0-(0-res)%mod)
```
***

### 6. 后缀表达式
#### 解析
后缀表达式可以表示为树的形式（后序遍历，逆波兰表达式）；所以给的n个加号和m个减号实际上是只需要有一个加号和一个减号（加减号范围：1~m+n），所以当m=0时，全部数的和即是结果；
m>0时，加上最大值减去最小值后，加上所有元素的绝对值。

#### 代码
```python
import sys
read=lambda:[int(x) for x in sys.stdin.readline().split()]
n,m=read()
a=read()
a.sort()

len=len(a)
sums=0
if m==0:
    sums=sum(a)
else:
    sums+=a[-1]-a[0]
    for i in range(1,len-1):
        sums+=abs(a[i])
print(sums
```
***

### 7. 灵能传输（难点在于转化为前缀和问题以及确定最短的路径走法）
#### 解析

求解整组的

**1. 将数字序列的互相传输转化为前缀和序列，此时一次操作只是$S_{i}$与$S_{i-1}$交换位置**
**2. 结果是求得所有相邻前缀和绝对值的最小值，即$\min(\max|S_{i}-S_{i-1}|)$ **
**3. 将前缀和序列排序，$S_{0}$和$S_{n}$为起点和终点，可能最小值和最大值并不是它们，所以最优解法是从$S_{0}$到最小值，从$S_{n}$到最大值；同时每隔一个点做一次**
![](https://img-blog.csdnimg.cn/58e444ccccfe49bc8783b2b8fcd381a3.png)

#### 代码
```python
import sys
read=lambda:[int(x) for x in sys.stdin.readline().split()]
T,=read()
for _ in range(T):
    n,=read()
    a=[0]+read()
    s=[0 for i in range(n+1)]
    st=[False for i in range(n+1)]
    for i in range(1,n+1):
        s[i]=s[i-1]+a[i]
  
    if s[0]<s[-1]:
        s0,sn=s[0],s[-1]
    else:
        s0,sn=s[-1],s[0]
    s.sort()
    s0,sn=s.index(s0),s.index(sn)
    
    l,r=0,n
    ##最终状态，使用走过的路径作为前缀和，求得最小的最大ai
    f=[0 for i in range(n+1)]
    for i in range(s0,-1,-2):
        st[i]=True
        f[l]=s[i]
        l+=1
    for i in range(sn,n+1,2):
        st[i]=True
        f[r]=s[i]
        r-=1
    for i in range(n+1):
        if not st[i]:
            f[l]=s[i]
            l+=1
    
    res=0
    for i in range(1,n+1):
        res=max(res,abs(f[i]-f[i-1]))
    print(res)
```
***











