---
title: 素性测试
index_img: /img/algorithm.png
categories:
- 数论
tags:
- 数论
- 工具函数
- C & C++
comment: valine
math: true
---

# 前言

本文是信息安全基础实验中的素性测试方法
<!-- more -->

# 素性测试

## 确定性素数测试
1. 从1到n^1/2开始判定
2. 找到{2，3，···，n^1/2}中所有的素数	Eratosthenes筛选法
3. 让输入去整除这些素数
***

## Miller-Rabin素性测试（不确定性）
使用快速乘法和快速幂，使用位运算方式判断q的存在
判断奇数（t&1）,最后一位为1一定为奇数
**对a^(2^i\*q)进行处理，使用快速乘法来求解；**
$$
\begin{aligned}
n = 2^{k}\cdot q +1,\quad
a^{n-1}=1 mod\quad n
\end{aligned}  
\implies
(a^{q}-1)\prod_{i=0}^{k-1}(a^{i}+1) =0\quad mod\quad n 
$$

```C++
for(int i=0;i<k;i++)
{
	temp2=Quick_mul(temp1,temp1,n);
	temp1=temp2;
}
```
### 依据：素数性质
1.	任意素数n都可以表示为*2^k\*q+1*；除n=2外，其余素数均为奇数	**（反之不一定成立、程序中必须对该性质进行检验：2^k\*q=n-1）**
2.	欧拉定理：n为素数时，a^(n-1)=1 mod n
### 判断依据
	已知n=2^k*q+1，若为n为素数，下面两个公式至少有一个成立
	1. a^q=1 mod n
	2. 存在一个i(0<=i<=q-1)，使得 a^(2^i*q)=-1 mod n 或者 a^(2^i*q)=n-1 mod n
***

## 乘法逆元
存在乘法逆元的充要条件：两个数的最大公约数为1
### 扩展欧几里得算法
欧几里得算法：
```C++
int gcd(int a, int b)
{
	return b ? gcd(b, a % b) : a;
}
```
#### 递归方法
扩展欧几里得算法（递归）：
```C++
ll gcdEx(ll a,ll b,ll &x,int &y)
{
    if(b==0)
    {
        x=1,y=0 ;
        return a ;
    }
    else
    {
        int r=gcdEx(b,a%b,x,y);
        /* r = GCD(a, b) = GCD(b, a%b) */
        int t=x ;
        x=y ;
        y=t-a/b*y ;
        return r ;
    }
}
```
#### 迭代算法
可以使用迭代的方法进行乘法逆元的求解：
通过对公式的推导，得到递推式，正向进行迭代；

有几个r=a%m，在a不等于1时，进行几次迭代
```C++
long mod_reverse(long a,long m) // 若返回-1，则表示整数a关于模m的乘法逆元不存在
{
 	long y=0,x=1,r=a%m,q,temp,mInit=m;
 	if(r<0)r=r+m;
 	while((m%r)!=0) //有几个r=a%m，在a不等于1时，进行几次迭代
 	{
 		 a=m;m=r;
  		 q=a/m,r=a%m;
 		 temp=x;x=y-x*q;y=temp;
 	}
 	if(r!=1)return -1;	//若存在逆元，r一定为1，否则不存在
 	if(x<0)x=x+mInit;
 	return x;
}
```
***

## 技巧
计算2^q：使用快速幂算法
计算a^(2^i * q)：求出2^q后，使用快速乘法算法
在ubuntu下的程序，对0求同余会导致Floating Exception




