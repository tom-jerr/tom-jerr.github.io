---
title: 信息安全基础实验知识点
index_img: /img/algorithm.png
categories:
- 信息安全
tags:
- 数论
- 信息安全
- C & C++
comment: valine
math: true
---

# 前言

本文是对信息安全基础实验的内容进行的一些总结
<!-- more -->

# 信息安全基础实验

## 1. 数论基础

### 1.1 模指数运算

​	在`unsigned int`情形下，计算模指数幂很难用`pow`函数直接求解；这里使用平方乘的思想进行求解。
$$
m^{10} = m^{2^{3}+2}
$$

$$
= ((((m^{2})*m^{0})^{2}*m^{0})*m)^{2}
$$

#### 伪代码：

~~~C
int ans = 1;
指数求解为二进制串
for 每个element：
	ans = ans * ans % m;
	if (element == 1) ans = ans * a % m;
~~~

#### 实验代码

~~~C++
unsigned int mod_exp(unsigned int a, unsigned int e, unsigned int m)
{
	unsigned int result = 1;
	unsigned int power = a % m;
	std::vector<int> binary(100); 
	long long i = 0;
	while (e > 0) {
		if (e % 2 == 1) {
			binary[i] = 1;
		}
		if (e % 2 == 0) {
			binary[i] = 0;
		}
		i++;
		e /= 2;
	}
	i--;
	for (; i >= 0; i--) {
		result = (result * result) % m; 
		if (binary[i] == 1) {
			result = (result * power) % m;
		}
	}
	return result;
}
~~~

***

### 1.2 素性检测

#### 1.2.1 确定性素性检测

##### Eratosthenes素数筛选法

埃式筛法；如果一个数是素数，将它本身所有的倍数都删去；

每个数最大的素因子都$\sqrt{n}$，所以从2枚举到$\sqrt{n}$。

**代码**

~~~C++
bool prime_test(unsigned int a)
{
	if (a == 0) { return false; }
	if (a == 1) { return false; }
	if (a == 2) { return true; }
	double n_sqr = sqrt(a);
	unsigned int n_sqr_ceil =(unsigned int) (n_sqr)+1;
	std::vector<int> flag(70000);
	unsigned int i, j, detect;
	for (i = 2; i <= n_sqr_ceil; i++) {
		j = i*i;
		while (j<=n_sqr_ceil){
			flag[j] = 1;
			j += i;
		}
	}
	i = 2;
	while (flag[i] == 0 && i <= n_sqr_ceil) {
		detect = a % i;
		if (detect == 0) { return false; }
		i++;
	}
	return true;
}
~~~



##### 欧拉筛法（线性筛法）

让每个合数只被最小的素数筛掉

**代码**

~~~C++
bool prime_test(unsigned int a)
{
	if (a == 0) { return false; }
	if (a == 1) { return false; }
	if (a == 2) { return true; }
	std::vector<int> flag(70000);
    std::vector<int> primes(70000);
	unsigned int i, j, detect, cnt = 0;
	for (i = 2; i <= n; i++) {
        if (flag[i] == 0){
            primes[cnt] = i;
            cnt ++;
        }
		for (int j = 0; j <= cnt && primes[j] <= a / i; j++){
            flag[primes[j] * i] = 1;
            if (i % primes[j] == 0) break;
        }
	}
	for (int k = 0 ;k <= cnt ; k++)
        if (a % primes[k] == 0) return false;
	return true;
}
~~~



#### 1.2.2 非确定性检测算法（Miller-Rabin）

基于素数的必要条件及欧拉定理可推出如下式子：
$$
\begin{aligned}
n = 2^{k}\cdot q +1,\quad
a^{n-1}=1 mod\quad n
\end{aligned}  
\implies
(a^{q}-1)\prod_{i=0}^{k-1}(a^{i}+1) =0\quad mod\quad n 
$$

所以得到非确定性的结论：随机挑选满足`gcd(a, n) = 1 `的数a

如果数n满足上述条件，n不一定是素数；

如果数n不满足上述条件，n一定是合数。

**代码**

~~~C++
std::string miller_rabin_prime_test(unsigned int n, unsigned int a) {
	if(n<2||n%2==0)return "not_prime";
	if(a<2||a>=n-1)return "error";
	int q=n-1;
	unsigned long long temp1;
    //求出q值
	while(!(q&1))
	{
		q>>=1;
	}
	for (int i=1;i<q;i++){
		temp1 = (unsigned long long) (temp1*a) % n;
	}
	if (temp1==1 || temp1==n-1) return "uncertain";
	for (int i = 1;i<k&&temp1!=(n-1);i++){
		temp1 = (unsigned long long)(temp1*temp1)%n
		if (temp1==n-1) return "uncertain";
	}
	return "not_prime";	
}
~~~



**基于大数库的版本**

~~~C++
BIGNUM* gcd_exp(BIGNUM* a,BIGNUM* b,BIGNUM* x,BIGNUM* y,BN_CTX* ctx){
	if (BN_is_zero(b)){
		BN_zero(y);BN_one(x);
		return a;
	}
	BIGNUM* mod_;BIGNUM* dv;BIGNUM* rem;BIGNUM* mult;
	mod_=BN_new();dv=BN_new();rem=BN_new();mult=BN_new();
	BN_mod(mod_,a,b,ctx);
	BIGNUM* temp = BN_new();
	temp = gcd_exp(b,mod_,y,x,ctx);
	BN_div(dv,rem,a,b,ctx);
	BN_mul(mult,dv,x,ctx);
	BN_sub(y,mult);
	
	BN_CTX_end(ctx);
	BN_CTX_free(ctx);
	BN_free(mod_);BN_free(dv);BN_free(rem);BN_free(mult);BN_free(temp);
	return temp
}

string mod_inverse(string a, string m) {
	BIGNUM* a1;BIGNUM* m1;BIGNUM* x;BIGNUM* y;BIGNUM* r1;
	const char* a_=a.data();
	const char* m_=m.data();
	string res="";
	a1=BN_new();m1=BN_new();x=BN_new();y=BN_new();r1=BN_new();
	BN_CTX *ctx=NULL;
	ctx=BN_CTX_new();
	BN_CTX_start(ctx);
	BN_dec2bn(&a1,a_);BN_dec2bn(&m1,m_);
	r1 = gcd_exp(a1,m1,x,y,ctx);	
		
	if(BN_is_one(r1)) res=BN_bn2dec(x);
	BN_CTX_end(ctx);
	BN_CTX_free(ctx);
	BN_free(a1);BN_free(m1);BN_free(r1);BN_free(x);BN_free(y);
	return res;
}
~~~

***

### 1.3 乘法逆元

使用扩展欧几里得算法求解；

欧几里得算法用于求两个数的最大公因数；
$$
gcd(a, b)=1,\quad ax+by=1

 \implies b\cdot y = 1 \quad mod\quad x
$$
**代码**

~~~C++
int euclid_mod_reverse(int a, int m) {
  // TODO: a * x = 1(mod m)，求a的逆元x并返回x
  	if(a<0||m<=0)return -1;
  	int y=0,x=1,r=a%m;
  	int q,temp;
  	int m1=m;
 	if(r<0)r=r+m;
 	while((m%r)!=0) //已计算完第i步，如果还需要计算第i+1步
 	{
 		 a=m;m=r;
  		 q=a/m,r=a%m;
 		 temp=x;
		 x=y-x*q;
		 y=temp;
 	}
 	if(r!=1)return -1;
 	if(x<0)x=x+m1;
 	return x;
}
~~~



**大数库版本**

~~~C++
//大数库自带的函数
/* string mod_inverse(string a, string m) {
	BIGNUM* a1;BIGNUM* m1;BIGNUM* r1;
	const char* a_=a.data();
	const char* m_=m.data();
	string res="";
	a1=BN_new();m1=BN_new();r1=BN_new();
	BN_CTX *ctx=NULL;
	ctx=BN_CTX_new();
	BN_CTX_start(ctx);
	if(BN_dec2bn(&a1,a_)&&BN_dec2bn(&m1,m_)){
		
		r1=BN_mod_inverse(r1,a1,m1,ctx);
	}
	if(r1!=NULL)res=BN_bn2dec(r1);
	BN_CTX_end(ctx);
	BN_CTX_free(ctx);
	BN_free(a1);BN_free(m1);BN_free(r1);
	return res;
} */

//基于大数基本函数进行的改写
BIGNUM* gcd_exp(BIGNUM* a,BIGNUM* b,BIGNUM* x,BIGNUM* y,BN_CTX* ctx){
	if (BN_is_zero(b)){
		BN_zero(y);BN_one(x);
		return a;
	}
	BIGNUM* mod_;BIGNUM* dv;BIGNUM* rem;BIGNUM* mult;
	mod_=BN_new();dv=BN_new();rem=BN_new();mult=BN_new();
	BN_mod(mod_,a,b,ctx);
	BIGNUM* temp = BN_new();
	temp = gcd_exp(b,mod_,y,x,ctx);
	BN_div(dv,rem,a,b,ctx);
	BN_mul(mult,dv,x,ctx);
	BN_sub(y,mult);
	
	BN_CTX_end(ctx);
	BN_CTX_free(ctx);
	BN_free(mod_);BN_free(dv);BN_free(rem);BN_free(mult);BN_free(temp);
	return temp
}

string mod_inverse(string a, string m) {
	BIGNUM* a1;BIGNUM* m1;BIGNUM* x;BIGNUM* y;BIGNUM* r1;
	const char* a_=a.data();
	const char* m_=m.data();
	string res="";
	a1=BN_new();m1=BN_new();x=BN_new();y=BN_new();r1=BN_new();
	BN_CTX *ctx=NULL;
	ctx=BN_CTX_new();
	BN_CTX_start(ctx);
	BN_dec2bn(&a1,a_);BN_dec2bn(&m1,m_);
	r1 = gcd_exp(a1,m1,x,y,ctx);	
		
	if(BN_is_one(r1)) res=BN_bn2dec(x);
	BN_CTX_end(ctx);
	BN_CTX_free(ctx);
	BN_free(a1);BN_free(m1);BN_free(r1);BN_free(x);BN_free(y);
	return res;
}
~~~

***



## 2. 伪随机数生成器

可以产生任意长度的伪随机序列；通过种子使用**确定性的算法**得到伪随机序列；

**性质：**

	1. 伪随机性：与随机数不可区分
 	2. 可重现：相同种子产生相同序列

### 2.0 伪随机数

随机数在密码算法和协议中广泛应用：认证协议、产生会话密钥、
流密码；
随机数具有随机性：均匀分布、难以重现；
伪随机数通过伪随机数生成器产生，近似随机数；

### 2.1 LCG（线性同余生成器）

每次产生一个随机数
$$
x_{i} = ax_{i - 1}+c\quad mod\quad m
$$
其中a, c, m为参数；$x_{0}$为种子；

#### 安全性

1. 全周期：{0，1，2，···，m-1}中任意数都可能被生成；
2. 不可预测：无法基于$x_{0}, x_{1},···,x_{i-1}$推测出$x_{i}$

对于任意参数配置，线性同余生成器无法满足全周期
例如：m = 32，a = 7，c = 0，产生序列{7, 17, 23, 1, 7,…}

参数(a, c, m) + 伪随机数 $x_{i}$→ 后续伪随机数序列{$x_{i+1}$, $x_{i+2}$,…}
增强方法：使用系统时钟修正增量

#### 缺点

线性同余位随机数生成器不具备可证明的安全性

### 2.2 BBS伪随机数生成器

一种可证明安全的伪随机数生成器：BBS (Blum Blum Shub) 伪
随机数生成器



选取素数p, q，满足$p \quad mod \quad 4 =q \quad mod \quad 4 = 3 $；$n=pq$

$$
x_{i} = x_{i - 1}^{2}\quad mod\quad n
$$
每次产生一个随机bit（选择重要的bit位），通过循环多次生成一个随机数

#### 代码实现

~~~C
int last_bit(x){
    return x&0x1;
}

int parity_even(x){
    int count = 0;
    while (x){
        if (x&0x1) count++;
        x >>= 1;
    }
    return count % 2 == 0 ? 0 : 1;
}

int parity_odd(x){
    reutrn 1 - parity_even(x);
}

unsigned int bbs_rand(int flag) {
    int b[32] = {0}, temp[1000];
    unsigned long tmp=_bbs_seed;
    unsigned int res = 0;
    for(int i=0;i<32;i++){
        int k = 0,count=0;
    	tmp=(tmp*tmp)%_n;
        switch(flag){
            case 0: b[i] = last_bit(tmp);
            case 1: b[i] = parity_odd(tmp);
            case 2: b[i] = parity_even(tmp);
        }
        // unsigned long len = tmp;
    	// while(len){
    	// 	if(len%2==0)temp[k]=0;
    	// 	if(len%2==1){
    	// 		temp[k]=1;
        //         count++;
    	// 	}
    	// 	k++;
    	// 	len/=2;
    	// }
    	// if(flag==0)b[i]=temp[0];
    	// if(flag==1){
    	// 	if(count%2==1)b[i]=0;
    	// 	if(count%2==0)b[i]=1;
    	// }
    	// if(flag==2){
    	// 	if(count%2==1)b[i]=1;
    	// 	if(count%2==0)b[i]=0;
    	// }
        // if (flag != 0 && flag != 1 && flag != 2)return res;
    }
    
    for (int i=0;i<32;i++){
    	if(b[i]==1){
    		res+=exp(2,31-i);   
    	}
    }
    return res;
}
~~~

***

## 3.OpenSSL

开源密码学库
安装：
~~~shell
sudo apt-get install libssl-dev
~~~

编译指令：(动态链接库)

~~~shel
gcc <源文件> -o <可执行文件> -lcrypto
~~~

大数运算库名称：crypto
头文件和库文件已在环境变量LD_LIBRARY_PATH和
CPLUS_INCLUDE_PATH（C_INCLUDE_PATH）搜索路径中

***

## 4. 对称密码

加解密使用相同的密钥；非对称加密密钥分为公钥和私钥；

**优点**：加解密速度快，密钥管理简单，适合一对一通信
**缺点**：密钥分发困难，不适合一对多加密传输

### RC4

一种具有可变密钥长度的流密码（1~255 Bytes），一种对称加密算法，加解密双方（基于密钥）产生相同伪随机流，明文与伪随机流按**bit位**异或加密
**优点**：低错误传播，硬件实现简单，适用于较高传输错误的通信环境
**缺点**：扩散度低

#### 实现方式

基于256字节状态数组（初始化为单位数组）
• KSA算法：基于K置换状态数组
• PRNG算法：扩充状态数组，加密明文数据

基本实现：

~~~C
void swap(unsigned char& a, unsigned char& b) {
	unsigned char tmp = a;
	a = b;
	b = tmp;
}

/// <summary>
///		KSA + PRGA生成RC4密钥流
/// </summary>
/// <param name="key">用户输入的密钥</param>
/// <param name="data">需要加密的数据</param>
/// <param name="k">生成密钥流</param>
/// <returns>数据长度</returns>
int RC4_KSA(unsigned char key[], unsigned char data[], unsigned char k[]) {
	unsigned char S[256];
	unsigned char T[256];

	int keylen, datalen, i, j;
	for (i = 0;; i++) {
		if (key[i] == '\0') {
			keylen = i;
			break;
		}
	}
	for (i = 0;; i++) {
		if (data[i] == '\0') {
			datalen = i;
			break;
		}
	}

	for (i = 0; i < 256; i++) S[i] = i;
	if (keylen > 256) {
		for (i = 0; i < 256; i++) T[i] = key[i];
	}
	else {
		j = 0;
		for (i = 0; i < 256; i++, j++) {
			T[i] = key[j % keylen];
		}
	}

	i = 0; j = 0;
	for (i = 0; i < 256; i++) {
		j = (j + S[i] + T[i]) % 256;
		swap(S[i], S[j]);
	}

	//PRGA伪随机生成算法，生成密钥流
	int times = datalen; int m = 0; int tmp;
	while (times--){
		i = (i + 1) % 256;
		j = (j + S[i]) % 256;
		swap(S[i], S[j]);
		tmp = (S[i] + S[j]) % 256;
		k[m++] = S[tmp];
	}
	return datalen;
}
/// <summary>
///		RC4异或加密明文
/// </summary>
/// <param name="data">数据</param>
/// <param name="k">生成的密钥</param>
/// <param name="datalen">数据长度</param>
/// <returns>生成密文的字符串</returns>
string RC4_encrypt(unsigned char data[], unsigned char k[], int datalen) {
	for (int i = 0; i < datalen; i++) {
		data[i] ^= k[i];
	}
	string res((char*)data, datalen);
	return res;
}
/// <summary>
///		RC4异或解密明文
/// </summary>
/// <param name="data">数据</param>
/// <param name="k">生成的密钥</param>
/// <param name="datalen">数据长度</param>
/// <returns>解密明文的字符串</returns>
string RC4_decrypt(string cipher, unsigned char k[], int datalen) {
	char* data = (char*)cipher.c_str();
	for (int i = 0; i < datalen; i++) {
		data[i] ^= k[i];
	}
	string res((char*)data, datalen);
	return res;
}
~~~

**大数库实现：**

~~~C
// 该函数实现RC4解密算法功能
//  参数:
//      data - 输入的密文字符串
//      secret_key - 密钥
//  返回值:
//      string类型, 返回解密的结果。如果输入数据异常，则返回空字符串并退出
string rc4_decrypt(string data, string secret_key) {
    // TODO: 在此处实现你的代码
    unsigned char* output = (unsigned char*)malloc(data.length());
    if (data.length()==0 || secret_key.length()==0)return "";
	RC4_KEY key;
	RC4_set_key(&key,secret_key.length(),(const unsigned char*)secret_key.c_str());
	RC4(&key,(unsigned long)data.length(),(const unsigned char*)data.c_str(),output);
    string res((char*)output,data.length());
	return res;
}
~~~



### DES分组密码

一类对称加密算法：将明文进行分组，将每个明文分组作为整体进行加解密

Feistel密码结构：一种用于构造分组密码的密码结构
• 扩散：明文每一位影响密文许多位
• 混淆：隐藏密文与密钥统计关系
• 加解密遵循相似运算流程



分组长度64位，有效密钥长度56位（8位奇偶校验位）

![流程](https://github.com/tom-jerr/MyblogImg/raw/main/src/des.png)

#### 分组密码应用模式

使用分组密码处理包含多个分组长度的数据的加解密操作

1. ECB：并行加密、并行解密、随机访问

   ![](https://github.com/tom-jerr/MyblogImg/raw/main/src/ecb.png)

   

2. CBC：依赖初始向量IV（公开、随机）、串行加密、并行解密、随机访问

   ![](https://github.com/tom-jerr/MyblogImg/raw/main/src/cbc.png)

   

3. CTR：依赖Nonce（公开、随机、非重复）、并行加密、随机访问、预加密

   ![](https://github.com/tom-jerr/MyblogImg/raw/main/src/ctr.png)

#### 代码实现

~~~C
/*
    ivec参数是8字节的初始向量（CFB,CBC,OFB）
    使用CBC模式进行加密时；length参数实际上是string.length()
    使用CBC模式解密时；length参数为加密时(length/8 + 1) * 8;
    CFB模式的numbits参数是每次加密的比特数    
*/
void convert_string_to_des_block(string str, DES_cblock &output) {
    for(int i = 0; i < 8; ++i) {
        output[i] = str[i];
    }
}
string des_encrypt(string plain, string secret_key) {
    //DES-ECB模式
    DES_cblock key;
    DES_string_to_key((const char*)secret_key.c_str(),&key);
    DES_key_schedule keys;
    DES_set_key_checked(&key,&keys);
    
    DES_cblock plaintext,output;
    convert_string_to_des_block(plain,plaintext);
    DES_ecb_encrypt(&plaintext,&output,&keys,DES_ENCRYPT);
 	
    return (char*)output;
}
string des_decrypt(string cipher, string secret_key) {
    DES_cblock key;
    DES_string_to_key((const char*)secret_key.c_str(),&key);
    DES_key_schedule keys;
    DES_set_key_checked(&key,&keys);
    
    DES_cblock ciphertext,output;
    convert_string_to_des_block(cipher,ciphertext);
    DES_ecb_encrypt(&ciphertext,&output,&keys,DES_DECRYPT);
 	
 	return (char*)output;
}
~~~



### SHA1——哈希函数

将**任意长度**数据内容映射为固定长度哈希值
• 特性：单向性、抗碰撞
• 应用：数据完整性检测（防篡改）

![](https://github.com/tom-jerr/MyblogImg/raw/main/src/sha1.png)

#### SHA-1算法

预处理：填充、分块；不足512n bit填充空白块，最后加上填充长度；
分割字：将每个分块分割并扩展，共计产生80个字，字长32比特位；最后一个字的输出即为哈希值；

定义5个寄存器，基于字内容进行变换（经历4轮，每轮20步），最终形成SHA1哈希

#### 代码实现

~~~C
// 该函数实现SHA1 hash算法功能
//  参数:
//      msg - 输入的字符串
//  返回值:
//      string类型, 返回sha1消息摘要结果
string sha1_digest(string msg) {
    /*unsigned char buf[20];
    SHA1((const unsigned char*)msg.c_str(),msg.length(),buf);
    string res((char*)buf,20);*/
    SHA_CTX c;
    SHA1_Init(&c);
    unsigned char buf[20];
    SHA1_Update(&c, (unsigned char*)msg.c_str(), msg.length());
    SHA1_Final(&(buf[0]), &c);
    string res((char*)buf, 20);
    return res;
}
~~~



## 5. 非对称密码

### RSA加密

RSA三元组：(N, e, d）
大素数：p和q，$N=pq$

随机选取素数e，e和d为正整数，满足$e*d \quad mod\quad (p-1)(q-1) = 1$

$PK = (e, N)，	SK=(d,N)$

加密：$C=M^{e} mod N$

解密：$M=C^{d}mod N$

### 密钥函数

密钥反序列化：OpenSSL私钥含有e

~~~C
RSA* rsa = RSA_new();
memcpy(pk, 4, &len_n); // 前4个字节存储n的长度
BN_bin2bn(pk+4, len_n, rsa->n); /* 接下来len_n个字节存储n的值*/
Memcpy(pk+4+len_n, 4, &len_e);
BN_bin2bn(pk+len_n+8, len_e, rsa->e);
~~~

### RSA加解密

从文件中加载公私钥：

~~~C
bool load_RSA_keys() {

    rsa_private_key = RSA_new();
    rsa_public_key = RSA_new();
    FILE *fpub = NULL;
    FILE *fpri = NULL;
    
    if ((fpub = fopen(PUBLICKEY, "r")) == NULL ||(fpri = fopen(PRIVATEKEY, "r")) == NULL){
        return false;
    }
   
    rsa_public_key=PEM_read_RSA_PUBKEY(fpub, &rsa_public_key,NULL,NULL);
    if (rsa_public_key== NULL){
        return false;
    }
   
    rsa_private_key=PEM_read_RSAPrivateKey(fpri,&rsa_private_key,NULL,NULL); 
    if (rsa_private_key== NULL){
       return false;
    }

    fclose(fpub);
    fclose(fpri);

    return true;
}
~~~

利用大数库函数进行RSA加密和解密：

~~~C
// 该函数用于进行rsa公钥加密
//  参数:
//      plaintext 代表输入的明文字符串
//  返回值:
//      string类型, 返回加密的结果
string RSA_Encryption(string plaintext)
{
    load_RSA_keys();

    char* cipher = (char *)malloc(RSA_size(rsa_public_key)); 
    memset(cipher, 0, RSA_size(rsa_public_key)); 
    RSA_public_encrypt(plaintext.length(), (unsigned char *)plaintext.c_str(), (unsigned char*)cipher, rsa_public_key, RSA_PKCS1_OAEP_PADDING); 
    
    string res(cipher, plaintext.length()); 
    return res; 
}

// 该函数用于进行rsa私钥解密
//  参数:
//      ciphertext 代表输入的密文字符串
//  返回值:
//      string类型, 返回解密的结果
string RSA_Decryption(string ciphertext)
{
    load_RSA_keys();

    char * plain = (char *)malloc(RSA_size(rsa_private_key));
    memset(plain, 0, RSA_size(rsa_private_key));
    RSA_private_decrypt(RSA_size(rsa_private_key),(unsigned char *)ciphertext.c_str(),(unsigned char *)plain,rsa_private_key, RSA_PKCS1_OAEP_PADDING);
        

    string res(plain, ciphertext.length());
    return res;
}
~~~

**使用BN库中函数实现RSA加密**

~~~C
int zhuanhuan(int a)//将十六进制转换为十进制
{
	if (a < 60)
	{
		a = a - '0';
	}
	if (a > 64)
	{
		a = a - 'A' + 10;
	}
	return a;
}
void main()
{
	BIGNUM* p = BN_new();    //大素数p
	BIGNUM* q = BN_new();  //大素数q
	BIGNUM* n = BN_new();    //n=p*q
	BIGNUM* fn = BN_new();   //fn=(p-1)*(q-1)
	BIGNUM* d = BN_new();    //d=e-1 mod (n)
	BIGNUM* e = BN_new();   //整数e，1<e<fn且gcd(fn, e)=1
	BIGNUM* r = BN_new();
	BIGNUM* M = BN_new();    //明文
	BIGNUM* C = BN_new();    //密文
	BIGNUM* one = BN_new();  //将one设置为1
	BN_one(one);
	int length;
	char str[100] = "0";
	char* show;
	int bits = 512;     //512bits
	int i, j, t;
	int sum = 0;
	printf("请输入要加密的的明文：");
	scanf_s("%s", str, sizeof(str));
	length = strlen(str);                //记录明文的长度
	BN_bin2bn((const unsigned char*)str, length, M);            //将明文以十六进制转换为大数
	printf("明文:%s\n", str);
	BN_generate_prime(p, bits, 1, NULL, NULL, NULL, NULL);       //生成512bits的大素数p
	BN_generate_prime(q, bits, 1, NULL, NULL, NULL, NULL);     //生成512bits的大素数q
	BN_CTX* ctx = BN_CTX_new();         //上下文结构		
	BN_mul(n, p, q, ctx);            //n=p*q
	BN_sub(p, p, one);
	BN_sub(q, q, one);
	BN_mul(fn, p, q, ctx);           //fn=(p-1)*(q-1)
	do
	{
		BN_rand_range(e, fn); //产生的0 < e < fn的随机数
		BN_gcd(r, e, fn, ctx); //r = e, fn最大公约数
	} while (!BN_is_one(r)); //判断r是否等于1
	BN_mod_inverse(d, e, fn, ctx);    //模逆运算
	//公钥加密 C = M^e mod n
	BN_mod_exp_simple(C, M, e, n, ctx);
	show = BN_bn2hex(C);     //将密文转换为十六进制
	printf("密文:%s\n", show);
	//私钥解密 M = C^d mod n。
	BN_mod_exp_simple(M, C, d, n, ctx);
	show = BN_bn2hex(M);
	//printf("%x",show);//测试
	printf("\n解密后的明文:%s", show);  //将解密后的明文转换为十六进制
	printf("\n解密后的明文:");

	for (i = 0; i < length; i++)  //将解密后的明文转化为对应的ASCII的字符
	{
		j = *(show + 2 * i);   //每两位为一个整体
		t = *(show + 2 * i + 1);
		j = zhuanhuan(j);
		t = zhuanhuan(t);
		sum = j * 16 + t;
		printf("%c", sum); //将ASCII的字符输出
	}
	//释放结构
	BN_CTX_free(ctx);
	BN_free(p);
	BN_free(q);
	BN_free(n);
	BN_free(fn);
	BN_free(d);
	BN_free(e);
	BN_free(r);
	BN_free(M);
	BN_free(C);
}
~~~

### RSA签名

$e*d \quad mod\quad (p-1)(q-1) = 1$

$PK = (e, N)，	SK=(d,N)$

签名：$S=M^{d} mod N$

验签：$M=S^{e}mod N$，判断签名是否合法；



RSA签名可以使用RSA_sign或者RSA_private_encrypt；

RSA验证签名可以使用RSA_vertify或者RSA_public_decrypt;

**代码**

~~~C
// 该函数用于进行rsa签名生成
//  参数:
//      input 代表输入的明文字符串
//  返回值:
//      string类型, 返回解密签名结果后的明文
string RSA_signature_signing(string input)
{
    load_RSA_keys();

    int flag = 0;
    char * sign =(char*)malloc(RSA_size(rsa_private_key));
	unsigned int siglen = (unsigned int)RSA_size(rsa_private_key);
    flag = RSA_sign(NID_sha1,(unsigned char *)input.c_str(),input.length(),(unsigned char *)sign,&siglen,rsa_private_key);
  
    string res(sign,siglen);
    return res;
}

// 该函数用于进行rsa签名验证
//  参数:
//      message 代表输入的签名结果
//      signature 代表签名的结果
//  返回值:
//      bool类型, 返回签名的结果, 验证成功为返回true, 失败返回false
bool RSA_signature_verify(string message, string signature)
{
    load_RSA_keys();
    bool flag = RSA_verify(NID_sha1,(unsigned char *)message.c_str(),message.length(),(unsigned char *)signature.c_str(),signature.length(),rsa_public_key);
    return flag;
}
~~~