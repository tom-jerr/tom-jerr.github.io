---
title: 汇编程序
index_img: /img/assembly.png
categories:
- 汇编语言
tags:
- 汇编
- C&C++
comment: valine
math: true
---

# 前言

本文是汇编语言第四章内容总结
<!-- more -->

# 汇编程序

## 伪指令

segment和ends是一对成对的伪指令

segment说明一个段开始

ends说明一个段结束

~~~asm
name segment
name ends
~~~

### 程序结束标记

end为汇编程序的结束标记

assume：假设某一段寄存器和程序中的某个段相关联

### 程序返回

~~~assembly
mov ax,4c00H
int 21H
~~~

***

## [Bx]和LOOP

### [bx]与内存单元

[bx]也是内存，bx的偏移存放在bx寄存器中

~~~assembly
mov ax,[bx] ds:bx 1000:20 2字节
mov al,[bx] ds:bx 1000:20 1字节
~~~

[bx] 中值 = [[ds]*16 + bx]

### Loop指令

loop指令执行，进行两步操作：

1. (cx) = (cx) - 1
2. 判断cx中的值，不为零转至标号处；否则向下执行

***

## 寻址方式

![](C:\Github_io\source\img\MyblogImg\src\寻址方式.png)

***

## jmp跳转指令

jmp指令机器码是EB 03；

读取到jmp指令时；IP = IP + 指令长度；

cpu执行EB 03时，修改IP，（IP）值加3

**机器码中不包含转移的目的地址，包含的是转移的位移（由编译器计算）**

### jmp short 标号

8位位移

段内短转移；对IP的修改范围为-128~127

编译时算出

### jmp near ptr 标号

16位位移

段内近转移；对IP修改范围-32768~32767

编译时算出

### jmp far ptr 标号

实现的是段间转移，又成为远转移

(CS) = 标号所在段的段地址

(IP) = 标号所在段中的偏移地址

far ptr使用标号的段地址和偏移地址修改CS和IP

### jmp 16位寄存器

直接跳转到该地址(CS:IP)

### jmp word ptr 内存地址单元（段内转移）

~~~assembly
mov ax,0123h
mov ds:[0],ax
jmp word ptr ds:[0]
~~~

执行后，(IP) = 0123H

***

## call & ret

### ret 

ret指令用栈中的数据，修改IP的内容，实现近转移

1. (IP) = ((ss)*16 + (sp))
2. (sp) = (sp) + 2

### retf

ret指令用栈中的数据，修改IP的内容，实现远转移

1. (IP) = ((ss)*16 + (sp))
2. (sp) = (sp) + 2
3. (CS) = ((ss)*16 + (sp))
4. (sp) = (sp) + 2

### call指令

1. 将当前的IP或者CS & IP压入栈中
2. 转移

call不能实现短转移

#### call 标号

相当于

~~~assembly
push IP
jmp near ptr 标号
~~~

1. (sp) = (sp) - 2

   ((ss)*16 + (sp)) = (IP)

2. (IP) = (IP) + 16位位移

~~~assembly
mov ax,0	;ax = 0, ip point to 1000:3
call s		;ax = 0, ip point to 1000:6
			;push ip, ip point to 1000:7
int ax
s:pop ax	;ax = 6
~~~

### call far ptr 标号
~~~assembly
push CS
push IP
jmp far ptr 标号
~~~

### call word ptr 内存单元地址

~~~assembly
push IP
jmp word ptr 标号
~~~

入栈 (sp) = (sp) - 2

### call dword ptr 内存单元地址

传递双字

~~~assembly
push CS
push IP
jmp dword ptr 标号
~~~

***

## 子程序和标志寄存器

寄存器冲突可能造成程序错误

SF、OF、CF、SF

PF：奇偶标志位，bit位中1的个数是否为偶数

### cmp指令

只比较，相当于进行sub指令，但是不保存结果，只改变结果寄存器

cmp a,b