---
title: 数论-算法
index_img: /img/acm.png
categories:
- 数论
- 算法
tags:
- 数论
- 算法
comment: valine
math: true
---

# 前言

本文是选取了一些数论的典型问题和一些蓝桥杯真题对数论进行总结
<!-- more -->

# 数论

## 1. 等差数列
实际上可以所有元素排列都是公差的倍数，所以只要将倍数之间的最大公因数求出来，就可以将结果得到
**注意：公差可能有为0的可能**
### 代码
```python 
import sys
read=lambda:[int(x) for x in sys.stdin.readline().split()]
n,=read()
a=read()
a.sort()

def gcd(a,b):
    if b==0:
        return a
    res=gcd(b,a%b)
    return res

d=0
for i in range(1,n):
    d=gcd(d,a[i]-a[0])

if d==0:
    print(n)
else:
    print((a[-1]-a[0])//d+1)
```
***

## 2. X的因子链
### 涉及数学知识（解析）
1. 数论：任何一个数N都可以分解成若干素数的幂指数乘积，形如：
$$
N = P_{1}^{\alpha_{1}}P_{2}^{\alpha_{2}}\cdots  P_{n}^{\alpha_{n}}
$$
   所以所有的因子个数不大于$ \alpha_{1}+\alpha_{2}\cdots+\alpha_{n} $

2. 组合计数： 计算有多少方案可以满足，因为可能有多个相同的素因子；所以采用组合计数
3. 总的方案数式子：
$$
\frac{(\alpha_{1}+\alpha_{2}\cdots+\alpha_{n})!}{\alpha_{1}!\alpha_{2}!\cdots\alpha_{n}!}
$$
4. 最大序列长度就是质因子的个数之和
5. 关键在于分解质因子，使用素数筛选法
### 线性筛素数法（实际应用非常多）
#### 思想
每一个数n，只会被它的最小质因子筛掉
st[i]中存储的是 i 的最小质因子，当 i 可以整除primes[ j ]时，退出内层循环
#### 示例代码
```python
for i in range(2,n+1):
	if st[i]==0:
		st[i]=primes[cnt]=i
		cnt+=1
	j=0
	while i*primes[j]<=n:
		st[primes[j]*i]=primes[j]
		if i%primes[j]==0: break
```

### 代码：
```python
import sys
import math
def get_primes(n):
    primes,count=[],[]
    ##分解质因数
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            primes.append(i)
            cnt=0
            while n%i==0:
                n//=i
                cnt+=1
            count.append(cnt)
    ##如果n是素数直接加入primes,count为1
    if n>1:
        primes.append(n)
        count.append(1)
    return primes,count
    
while True:
    try:
        p,c=get_primes(int(input()))
        ##math库中有直接求阶乘的函数factorial
        res=int(math.factorial(sum(c)))
        for i in range(len(p)):
            res//=int(math.factorial(c[i]))
        print(sum(c),res)
    except :
        break
    
```
**第二版使用线性筛法**
~~~python
#质因数分解求出因数
#序列最长长度就是因数个数： (α1+α2+…+αk)
#最长序列个数就是（因数）全排列个数： (α1+α2+…+αk)!/α1!·α2!·…·αk!
#minp中存放最小的质因数
import math
from sys import stdin
N = (1 << 20) + 10
st = [0] * N
primes = [0] * N
minp = [0] * N


def get_prime(n):
    cnt = 0
    for i in range(2, n+1):
        if st[i] == 0:
            primes[cnt] = i
            minp[i] = i
            cnt += 1
        j = 0
        for j in range(cnt):
            ans = i*primes[j]
            if ans > n:
                break
            st[ans] = True
            minp[ans] = primes[j]
            if i % primes[j] == 0:
                break
            

get_prime(1024*1024)
while True:
    try:
        x = int(input())
        total = 0
        k = 0
        sums = [0 for i in range(1000)] #sums应该作为每次的中间变量
        while x>1:
            p = minp[x]
            while x % p == 0:
                x = x//p
                sums[k] += 1
                total += 1
            k += 1
        res = math.factorial(total)
        for i in range(k):
            res //= math.factorial(sums[i])
    
        print(total, res)
    except:
        break
~~~
***

## 3. 正约数之和为定值
### 解析
一个数分解成质因数
$$
N = P_{1}^{\alpha_{1}}P_{2}^{\alpha_{2}}\cdots  P_{k}^{\alpha_{k}}
$$
约数个数：
$$
{\alpha_{1}}+{\alpha_{2}}+\cdots+{\alpha_{k}}
$$
约数之和：
$$
(1+P_{1}+P_{1}^{2}+\cdots+P_{1}^{\alpha_{1}})(1+P_{2}+P_{2}^{2}+\cdots+P_{2}^{\alpha_{2}})\cdots(1+P_{k}+P_{k}^{2}+\cdots+P_{k}^{\alpha_{k}})
$$
最终求解结果是所有满足约数之和满足S的
$$
P_{1}^{\alpha_{1}}P_{2}^{^{\alpha_{2}}}\cdots P_{k}^{\alpha_{k}}
$$
**实际上满足定值的正约数之和不是很多，可以直接进行暴力搜索**
**注意：通过对$\alpha_{1}$进行特判（是否为1），可以将暴力搜索的p降至$p^{2}<=s$，降低复杂度**

### 代码
```python
import sys; readline = sys.stdin.readline; from functools import reduce
read = lambda: [int(x) for x in readline().split()]
N=50000	#sqrt(2e9)
st=[False]*N
primes=[0]*N
cnt=0
def get_primes(n):
    global cnt
    for i in range(2,n+1):
        if not st[i]:
            primes[cnt]=i
            cnt+=1
        j=0
        while primes[j]*i<=n:
            st[primes[j]*i]=True
            if i%primes[j]==0:break
            j+=1


def is_prime(n):
    if n<N:
        return not st[n]
    i=0
    while primes[i]<=n//primes[i]:
        if n%primes[i]==0:return False
        i+=1
    return True

def dfs(last,prod,s):	#last表示上一个用的质数的下标是什么,product当前最高次项的结果,S表示每次处理后剩余多少
    if s==1:
        ans.append(prod)
        return
    
    if s-1> (1 if last<0 else primes[last])and is_prime(s-1):
        ans.append(prod*(s-1))
    i=last+1
    while primes[i]<=s//primes[i]:
        p=primes[i]
        j,t=1+p,p
        while j<=s:
            if s%j==0:
                dfs(i,prod*t,s//j)
            t*=p
            j+=t
        i+=1

get_primes(N-1)
##当多组数据相同时，考虑将计算过的数据存起来（使用字典或列表）
cache=dict()
while True:
    try:n,=read()
    except:break
    if n not in cache:
        ans=[]
        dfs(-1,1,n)
        cache[n]=(len(ans),ans.sort())
    print(cache[n][0])
    if cache[n][0]>0:
        print(' '.join(str(i)for i in ans))
```
***

## 4. 裴蜀定理——扩展欧几里得算法
### 求最大公因数——辗转相除法（应该是logN级别）
利用$gcd(a,b)=gcd(b,a\bmod b)$理论，进行递归实现
### 扩展欧几里得算法
利用
$$
ax+by=gcd(a,b),gcd(a,b)=gcd(b,a\bmod b)
$$
不断回溯x,y的值，求出满足条件的x和y
### 五指山
#### 解析
利用扩展欧几里得算法进行计算，将题目变为求
$$
an+bd=y-x
$$
求出的b是满足$an+bd=gcd(a,b)$，所以$b=b \times \frac{y-x}{gcd(a,b)}$，这是方程的一个特解
扩展欧几里得算法可以得到通解
$$
b=b_{0}+k \times \frac{n}{gcd(n,d)}
$$
$$
a=a_{0}-k \times \frac{d}{gcd(n,d)}
$$
选取其中最小的解即可
#### 代码
```python
import sys
read=lambda:[int(x) for x in sys.stdin.readline().split()]
T,=read()

def ex_gcd(a,b):
    if b==0:
        x,y=1,0
        return a,x,y
    res,y,x=ex_gcd(b,a%b)
    return res,x,y-(a//b)*x
    
for _ in range(T):
    n,d,x,y=read()
    gcd,res_a,res_b=ex_gcd(n,d)
    if (y-x)%gcd!=0:
        print("Impossible")
    else:
        res_b*=(y-x)//gcd
        n//=gcd
        print(res_b%n)
```
***

## 5.最大比例
### 辗转相减法
一般求最大公约数时，不使用，只有一些特殊情况使用
**求解最简分数的幂指数的最大公约数$(\frac{p}{q})^{r_{i}}$**
#### 示例代码
```C++
LL gcd_sub(LL a,LL b)
{
    if(b>a)swap(a,b);
    if(b==1)return a;
    return gcd_sub(b,a/b);
}
```
### 代码
```python
import sys
read=lambda:[int(x) for x in sys.stdin.readline().split()]
n,=read()
a=read()
a1,b1=[],[]
##注意排序
a.sort()
def gcd(a,b):
    if b == 0:
        return a
    else:
        return gcd(b,a%b)

##辗转相减法
def gcd_sub(a,b):
    if a<b:
        a,b=b,a
    if b==1:
        return a
    return gcd_sub(b,a//b)
        
for i in range(1,n):
    if a[i]!=a[i-1]:
        d=gcd(a[i],a[0])
        a1.append(a[i]//d)
        b1.append(a[0]//d)

up,down=a1[0],b1[0]
for i in range(1,len(a1)):
    up=gcd_sub(up,a1[i])
    down=gcd_sub(down,b1[i])
print(f"{up}/{down}")
```
***

## 6. 正则表达式
### 解析
正则表达式可以使用递归树表示，利用dfs进行递归搜索
1. 遇到左括号，递归搜索
2. 遇到|，递归搜索右侧并与之前res比较
3. 遇到右括号，直接退出
4. 遇到x，res加一后跳过
5. 直到走到字符串结尾
![](C:\Users\我\Desktop\截图\Snipaste_2022-10-19_20-27-30.png)
### 代码
```python
import sys
read=lambda:[input() for x in sys.stdin.readline().split()]
a=input()
k=0

def dfs():
    global k
    res=0
    while k<len(a):
        if a[k]=='(':
            k+=1    ##跳过'('
            res+=dfs()
            k+=1    ##跳过')'
        elif a[k]=='|':
            k+=1
            res=max(res,dfs())
        elif a[k]==')':break
        elif a[k]=='x':
            k+=1
            res+=1
        else:k+=1
        
    return res

print(dfs()) 
```
***

## 7.重复覆盖问题（糖果等搜索问题）
最快做法：Dancing links
### 经典做法
每一次找到没有被覆盖的列，枚举覆盖这个列的行
![](C:\Users\我\Desktop\截图\Snipaste_2022-10-19_21-03-24.png)
### 优化
1. 迭代加深
2. 找选择最少的列
3. 可行性剪枝（至少要选所有行）
**使用二进制表示每一列是否被选**
### 代码（IDA\*算法）
```python
import sys
read=lambda:[int(x) for x in sys.stdin.readline().split()]
n,m=110,1<<20
log2=[0]*m
col=[[] for i in range(n)]  #记录哪些行的这一列是1
n,m,k=read()
for i in range(m):log2[1<<i]=i  #计算log2(n)

for i in range(m):
    t=read()
    state=0 #二进制表示状态，即是否糖果已经被覆盖
    for j in range(k):
        state|=1<<t[j]-1    #state从0开始，所以先-1后再使得第j位变为1
    for j in range(m):
        if state>>j&1:
            col[j].append(state)    #加入可选

##求一个数的最低为1在什么地方
def lowbit(x):
    return x&-x

def h(state):   #最少需要再选几行
    res=0
    i=(1<<m)-1-state
    while i>0:
        res+=1
        for row in col[log2[lowbit(i)]]:
            i&=~row #把是1的位清空
    return res

def dfs(depth,state): 
    if depth==0 or h(state)>depth:
        return state==(1<<m)-1
    t=-1    #记录最少糖类的下标
    i=(1<<m)-1-state    #所有未被选的糖果
    while i>0:
        cc=lowbit(i)
        c=log2[cc]
        if t==-1 or len(col[t])>len(col[c]):t=c
        i-=cc   #每次减去最后一个1
        
    for row in col[t]:
        if dfs(depth-1,state|row):return True
    return False

depth=0
while depth<=m and not dfs(depth,0): depth+=1
if depth>m: depth=-1
print(depth)
```
***
### IDA\*算法2
```python
M=1<<20
N=110
log2=[0]*M
col=[[] for _ in range(N)]#记录有哪些行的这一列是1，即哪几包里有这一类糖
n,m,k=map(int,input().split())
for i in range(m):log2[1<<i]=i#辅助求log2(n)，直接让记录下来某个数的log2(n)是几

#用于求一个数最低位的1在哪个位置，如果是第k位，则会返回2^k
def lowbit(x):return x&-x

def dfs(depth,state):
    if depth==0 :#遍历到最底层
        return state==(1<<m)-1 #返回是否所类有的糖都被选了

    t=-1#记录最少的糖类的下标
    i=(1<<m)-1-state#找出所有没有被选过的糖，用全1-现状，1→0,0→1
    while i>0:#从右向左（严谨是低位向高位）遍历，去找有最少可选方案的那类糖
        cc=lowbit(i)#取第一个1，第一个没有选过的糖
        c=log2[cc]#求得它的位置
        if t==-1 or len(col[t])>len(col[c]):#找可选方案数最少的那类糖
            t=c
        i-=cc#找下一个，用i-cc表示将那一位1变成0，表示遍历过了
    for row in col[t]:#遍历其所有可选方案，看看有没有成功的可能
        if dfs(depth-1,state|row):#递归时深度应该-1，状态上或上方案row让选了的变成1
            return True
    return False#但凡有一类糖的所有选择方案都不行↑(上面遍历的是最少的方案的糖)，
                #说明对于这类糖没有可行解，那么说明在此深度depth下都无解，选depth包糖不够
for i in range(n):
    t=list(map(int,input().split()))
    state=0#用数字的二进制表示状态，从0开始
    #[00000]
    for j in range(k):
        state|=1<<t[j]-1#先运算-1后左移使第t[j]位变成1,(因为要从0开始，所以-1)
    #112-[00011]
    for j in range(m):
        if state>>j&1 :#如果这一列有数(这一位是1)
            col[j].append(state)#加入可选

# depth=0
# while depth<=m and not dfs(depth,0): #当选的包数≤总包数时，试探depth包是否可行，不可行就加深
#     depth+=1
# if depth>m:
#     depth=-1

#迭代加深，每次深度+1，dfs求在该深度下(选depth包糖)是否可行，不可行就加深，直至全选
for depth in range(m+2):
    if dfs(depth,0):
        break
if depth>m:#如果最终全选都不行，说明无解
    depth=-1

print(depth)
```
***
### 状态压缩DP
```python
import sys
N,M,INF = 110,1<<20+5,0x3f3f3f3f;
n,m,k=map(int,input().split())
w=[0]*N
for i in range(n):
    t=list(map(int,input().split()))
    for j in range(k):
        w[i]|=1<<t[j]-1

dp=[INF]*M    
dp[0]=0
for i in range(n):
    for j in range(1<<m):
        dp[j]=min(dp[j&(~w[i])]+1,dp[j])

if dp[1<<m-1]==INF:print(-1)
else: print(dp[1<<m-1])
```
### 总结
当数据较小时可以使用状态压缩DP进行求解，非常快
当数据较大时使用IDA\*算法求解，注意可行化剪枝和迭代加深






























