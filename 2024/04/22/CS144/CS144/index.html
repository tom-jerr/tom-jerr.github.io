<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CS144-TCP协议简单实现 | LZY的Code生活</title><meta name="author" content="LZY"><meta name="copyright" content="LZY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="CS144 项目">
<meta property="og:type" content="article">
<meta property="og:title" content="CS144-TCP协议简单实现">
<meta property="og:url" content="http://tom-jerr.github.io/2024/04/22/CS144/CS144/index.html">
<meta property="og:site_name" content="LZY的Code生活">
<meta property="og:description" content="CS144 项目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tom-jerr.github.io/img/work.png">
<meta property="article:published_time" content="2024-04-22T05:55:23.079Z">
<meta property="article:modified_time" content="2024-04-24T03:25:37.114Z">
<meta property="article:author" content="LZY">
<meta property="article:tag" content="TCP">
<meta property="article:tag" content="CS144">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tom-jerr.github.io/img/work.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://tom-jerr.github.io/2024/04/22/CS144/CS144/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CS144-TCP协议简单实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-24 11:25:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/work.png')"><nav id="nav"><span id="blog-info"><a href="/" title="LZY的Code生活"><span class="site-name">LZY的Code生活</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CS144-TCP协议简单实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-22T05:55:23.079Z" title="发表于 2024-04-22 13:55:23">2024-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-24T03:25:37.114Z" title="更新于 2024-04-24 11:25:37">2024-04-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Project/">Project</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CS144-TCP协议简单实现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Minnow"><a href="#Minnow" class="headerlink" title="Minnow"></a>Minnow</h1><ul>
<li>初始的<code>TCPSocket</code>是在Linux TCP&#x2F;IP栈上封装的一个类</li>
<li><code>lab4</code>开始自己构建<code>TCPPeer</code>对端进行数据传输，直接使用网卡上的IP数据包进行TCP包的构建</li>
<li><code>lab5</code>实现简易ARP协议，可以转换IP地址和MAC地址NetworkInterface</li>
<li><code>lab6</code>实现了最长前缀匹配的链路层选路算法IP route</li>
<li><code>lab7</code>实现了一个使用IP route、NetworkInterface的端到端的TCP报文传输</li>
</ul>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><h3 id="IP包"><a href="#IP包" class="headerlink" title="IP包"></a>IP包</h3><ul>
<li><p>IPv4数据包构建：不支持IP选项</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IPv4 Internet datagram header (note: IP options are not supported)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IPv4Header</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> LENGTH = <span class="number">20</span>;        <span class="comment">// IPv4 header length, not including options</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint8_t</span> DEFAULT_TTL = <span class="number">128</span>; <span class="comment">// A reasonable default TTL value</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint8_t</span> PROTO_TCP = <span class="number">6</span>;     <span class="comment">// Protocol number for TCP</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> <span class="title">serialized_length</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> LENGTH; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *   0                   1                   2                   3</span></span><br><span class="line"><span class="comment">   *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span><br><span class="line"><span class="comment">   *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">   *  |Version|  IHL  |Type of Service|          Total Length         |</span></span><br><span class="line"><span class="comment">   *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">   *  |         Identification        |Flags|      Fragment Offset    |</span></span><br><span class="line"><span class="comment">   *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">   *  |  Time to Live |    Protocol   |         Header Checksum       |</span></span><br><span class="line"><span class="comment">   *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">   *  |                       Source Address                          |</span></span><br><span class="line"><span class="comment">   *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">   *  |                    Destination Address                        |</span></span><br><span class="line"><span class="comment">   *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">   *  |                    Options                    |    Padding    |</span></span><br><span class="line"><span class="comment">   *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPv4 Header fields</span></span><br><span class="line">  <span class="type">uint8_t</span> ver = <span class="number">4</span>;           <span class="comment">// IP version</span></span><br><span class="line">  <span class="type">uint8_t</span> hlen = LENGTH / <span class="number">4</span>; <span class="comment">// header length (multiples of 32 bits)</span></span><br><span class="line">  <span class="type">uint8_t</span> tos = <span class="number">0</span>;           <span class="comment">// type of service</span></span><br><span class="line">  <span class="type">uint16_t</span> len = <span class="number">0</span>;          <span class="comment">// total length of packet</span></span><br><span class="line">  <span class="type">uint16_t</span> id = <span class="number">0</span>;           <span class="comment">// identification number</span></span><br><span class="line">  <span class="type">bool</span> df = <span class="literal">true</span>;            <span class="comment">// don&#x27;t fragment flag</span></span><br><span class="line">  <span class="type">bool</span> mf = <span class="literal">false</span>;           <span class="comment">// more fragments flag</span></span><br><span class="line">  <span class="type">uint16_t</span> offset = <span class="number">0</span>;       <span class="comment">// fragment offset field</span></span><br><span class="line">  <span class="type">uint8_t</span> ttl = DEFAULT_TTL; <span class="comment">// time to live field</span></span><br><span class="line">  <span class="type">uint8_t</span> proto = PROTO_TCP; <span class="comment">// protocol field</span></span><br><span class="line">  <span class="type">uint16_t</span> cksum = <span class="number">0</span>;        <span class="comment">// checksum field</span></span><br><span class="line">  <span class="type">uint32_t</span> src = <span class="number">0</span>;          <span class="comment">// src address</span></span><br><span class="line">  <span class="type">uint32_t</span> dst = <span class="number">0</span>;          <span class="comment">// dst address</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Length of the payload</span></span><br><span class="line">  <span class="function"><span class="type">uint16_t</span> <span class="title">payload_length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pseudo-header&#x27;s contribution to the TCP checksum</span></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">pseudo_checksum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set checksum to correct value</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">compute_checksum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a string containing a header in human-readable format</span></span><br><span class="line">  <span class="function">std::string <span class="title">to_string</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">parse</span><span class="params">( Parser&amp; parser )</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">serialize</span><span class="params">( Serializer&amp; serializer )</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><ul>
<li><p>TCPMessage包含TCPSenderMessage和TCPReceiverMessage</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TCPMessage</span></span><br><span class="line">&#123;</span><br><span class="line">  TCPSenderMessage sender &#123;&#125;;</span><br><span class="line">  TCPReceiverMessage receiver &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TCPSenderMessage</span></span><br><span class="line">&#123;</span><br><span class="line">  Wrap32 seqno &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> SYN &#123;&#125;;</span><br><span class="line">  std::string payload &#123;&#125;;</span><br><span class="line">  <span class="type">bool</span> FIN &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> RST &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// How many sequence numbers does this segment use?</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">sequence_length</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> SYN + payload.<span class="built_in">size</span>() + FIN; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TCPReceiverMessage</span></span><br><span class="line">&#123;</span><br><span class="line">  std::optional&lt;Wrap32&gt; ackno &#123;&#125;;</span><br><span class="line">  <span class="type">uint16_t</span> window_size &#123;&#125;;</span><br><span class="line">  <span class="type">bool</span> RST &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在IP上构建自己的TCP报文；将IP数据包通过TUN设备与网络上其他TCP进行通信</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPOverIPv4Adapter</span> : <span class="keyword">public</span> FdAdapterBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">std::optional&lt;TCPMessage&gt; <span class="title">unwrap_tcp_in_ip</span><span class="params">( <span class="type">const</span> InternetDatagram&amp; ip_dgram )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">InternetDatagram <span class="title">wrap_tcp_in_ip</span><span class="params">( <span class="type">const</span> TCPMessage&amp; msg )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;TCPMessage&gt; <span class="title">TCPOverIPv4Adapter::unwrap_tcp_in_ip</span><span class="params">( <span class="type">const</span> InternetDatagram&amp; ip_dgram )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// is the IPv4 datagram for us?</span></span><br><span class="line"><span class="comment">// Note: it&#x27;s valid to bind to address &quot;0&quot; (INADDR_ANY) and reply from actual address contacted</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">not</span> <span class="built_in">listening</span>() <span class="built_in">and</span> ( ip_dgram.header.dst != <span class="built_in">config</span>().source.<span class="built_in">ipv4_numeric</span>() ) ) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is the IPv4 datagram from our peer?</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">not</span> <span class="built_in">listening</span>() <span class="built_in">and</span> ( ip_dgram.header.src != <span class="built_in">config</span>().destination.<span class="built_in">ipv4_numeric</span>() ) ) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// does the IPv4 datagram claim that its payload is a TCP segment?</span></span><br><span class="line"><span class="keyword">if</span> ( ip_dgram.header.proto != IPv4Header::PROTO_TCP ) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is the payload a valid TCP segment?</span></span><br><span class="line">TCPSegment tcp_seg;</span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">not</span> <span class="built_in">parse</span>( tcp_seg, ip_dgram.payload, ip_dgram.header.<span class="built_in">pseudo_checksum</span>() ) ) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is the TCP segment for us?</span></span><br><span class="line"><span class="keyword">if</span> ( tcp_seg.udinfo.dst_port != <span class="built_in">config</span>().source.<span class="built_in">port</span>() ) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// should we target this source addr/port (and use its destination addr as our source) in reply?</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">listening</span>() ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( tcp_seg.message.sender.SYN <span class="keyword">and</span> <span class="keyword">not</span> tcp_seg.message.sender.RST ) &#123;</span><br><span class="line">    <span class="built_in">config_mutable</span>().source = Address &#123; <span class="built_in">inet_ntoa</span>( &#123; <span class="built_in">htobe32</span>( ip_dgram.header.dst ) &#125; ), <span class="built_in">config</span>().source.<span class="built_in">port</span>() &#125;;</span><br><span class="line">    <span class="built_in">config_mutable</span>().destination</span><br><span class="line">      = Address &#123; <span class="built_in">inet_ntoa</span>( &#123; <span class="built_in">htobe32</span>( ip_dgram.header.src ) &#125; ), tcp_seg.udinfo.src_port &#125;;</span><br><span class="line">    <span class="built_in">set_listening</span>( <span class="literal">false</span> );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is the TCP segment from our peer?</span></span><br><span class="line"><span class="keyword">if</span> ( tcp_seg.udinfo.src_port != <span class="built_in">config</span>().destination.<span class="built_in">port</span>() ) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tcp_seg.message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Takes a TCP segment, sets port numbers as necessary, and wraps it in an IPv4 datagram</span></span><br><span class="line"><span class="comment">//! \param[in] seg is the TCP segment to convert</span></span><br><span class="line"><span class="function">InternetDatagram <span class="title">TCPOverIPv4Adapter::wrap_tcp_in_ip</span><span class="params">( <span class="type">const</span> TCPMessage&amp; msg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TCPSegment seg &#123; .message = msg &#125;;</span><br><span class="line">  <span class="comment">// set the port numbers in the TCP segment</span></span><br><span class="line">  seg.udinfo.src_port = <span class="built_in">config</span>().source.<span class="built_in">port</span>();</span><br><span class="line">  seg.udinfo.dst_port = <span class="built_in">config</span>().destination.<span class="built_in">port</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create an Internet Datagram and set its addresses and length</span></span><br><span class="line">  InternetDatagram ip_dgram;</span><br><span class="line">  ip_dgram.header.src = <span class="built_in">config</span>().source.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">  ip_dgram.header.dst = <span class="built_in">config</span>().destination.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">  ip_dgram.header.len = ip_dgram.header.hlen * <span class="number">4</span> + <span class="number">20</span> <span class="comment">/* tcp header len */</span> + seg.message.sender.payload.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set payload, calculating TCP checksum using information from IP header</span></span><br><span class="line">  seg.<span class="built_in">compute_checksum</span>( ip_dgram.header.<span class="built_in">pseudo_checksum</span>() );</span><br><span class="line">  ip_dgram.header.<span class="built_in">compute_checksum</span>();</span><br><span class="line">  ip_dgram.payload = <span class="built_in">serialize</span>( seg );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip_dgram;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="FD操作"><a href="#FD操作" class="headerlink" title="FD操作"></a>FD操作</h3><ul>
<li>对FD的操作比如write和read，都是对系统调用的封装</li>
</ul>
<h2 id="TCP工作流程"><a href="#TCP工作流程" class="headerlink" title="TCP工作流程"></a>TCP工作流程</h2><ul>
<li>事件驱动模式进行TCP的监听，调用poll系统调用接收消息；设置回调，将网络上的IP数据包传递到我们设计的TCP上</li>
<li>TCPPeer构建测试程序，同样使用事件驱动，只是回调略有不同</li>
</ul>
<h3 id="初始化TCP"><a href="#初始化TCP" class="headerlink" title="初始化TCP"></a>初始化TCP</h3><ul>
<li>设置poll需要监听的事件<ol>
<li>收到数据包，将TCP报文传递给TCPPeer接收</li>
<li>读取<code>pipe</code>的字节传递给TCPPeer：用户在命令行输入字符串使用TCPSender发送到对端</li>
<li>从<code>Reassembler</code>中读取字节写入<code>LocalStreamSocket</code>：用户从reassembler中读取字符串，写入unix域套接字</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;TCPDatagramAdapter AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPMinnowSocket&lt;AdaptT&gt;::_initialize_TCP( <span class="type">const</span> TCPConfig&amp; config )</span><br><span class="line">&#123;</span><br><span class="line">  _tcp.<span class="built_in">emplace</span>( config );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up the event loop</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// There are three events to handle:</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 1) Incoming datagram received (needs to be given to TCPPeer::receive method)</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 2) Outbound bytes received from local application via a write()</span></span><br><span class="line">  <span class="comment">//    call (needs to be read from the local stream socket and</span></span><br><span class="line">  <span class="comment">//    given to TCPPeer)</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 3) Incoming bytes reassembled by the Reassembler</span></span><br><span class="line">  <span class="comment">//    (needs to be read from the inbound_stream and written</span></span><br><span class="line">  <span class="comment">//    to the local stream socket back to the application)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// rule 1: read from filtered packet stream and dump into TCPConnection</span></span><br><span class="line">  _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">    <span class="string">&quot;receive TCP segment from the network&quot;</span>,</span><br><span class="line">    _datagram_adapter.<span class="built_in">fd</span>(),</span><br><span class="line">    Direction::In,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="keyword">auto</span> seg = _datagram_adapter.<span class="built_in">read</span>() ) &#123;</span><br><span class="line">        _tcp-&gt;<span class="built_in">receive</span>( std::<span class="built_in">move</span>( seg.<span class="built_in">value</span>() ), [&amp;]( <span class="keyword">auto</span> x ) &#123; _datagram_adapter.<span class="built_in">write</span>( x ); &#125; );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// debugging output:</span></span><br><span class="line">      <span class="keyword">if</span> ( _thread_data.<span class="built_in">eof</span>() <span class="keyword">and</span> _tcp.<span class="built_in">value</span>().<span class="built_in">sender</span>().<span class="built_in">sequence_numbers_in_flight</span>() == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> _fully_acked ) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;DEBUG: minnow outbound stream to &quot;</span> &lt;&lt; _datagram_adapter.<span class="built_in">config</span>().destination.<span class="built_in">to_string</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; has been fully acknowledged.\n&quot;</span>;</span><br><span class="line">        _fully_acked = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123; <span class="keyword">return</span> _tcp-&gt;<span class="built_in">active</span>(); &#125; );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rule 2: read from pipe into outbound buffer</span></span><br><span class="line">  _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">    <span class="string">&quot;push bytes to TCPPeer&quot;</span>,</span><br><span class="line">    _thread_data,</span><br><span class="line">    Direction::In,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      std::string data;</span><br><span class="line">      data.<span class="built_in">resize</span>( _tcp-&gt;<span class="built_in">outbound_writer</span>().<span class="built_in">available_capacity</span>() );</span><br><span class="line">      _thread_data.<span class="built_in">read</span>( data );</span><br><span class="line">      _tcp-&gt;<span class="built_in">outbound_writer</span>().<span class="built_in">push</span>( <span class="built_in">move</span>( data ) );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( _thread_data.<span class="built_in">eof</span>() ) &#123;</span><br><span class="line">        _tcp-&gt;<span class="built_in">outbound_writer</span>().<span class="built_in">close</span>();</span><br><span class="line">        _outbound_shutdown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// debugging output:</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;DEBUG: minnow outbound stream to &quot;</span> &lt;&lt; _datagram_adapter.<span class="built_in">config</span>().destination.<span class="built_in">to_string</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; finished (&quot;</span> &lt;&lt; _tcp.<span class="built_in">value</span>().<span class="built_in">sender</span>().<span class="built_in">sequence_numbers_in_flight</span>() &lt;&lt; <span class="string">&quot; seqno&quot;</span></span><br><span class="line">                  &lt;&lt; ( _tcp.<span class="built_in">value</span>().<span class="built_in">sender</span>().<span class="built_in">sequence_numbers_in_flight</span>() == <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;s&quot;</span> )</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; still in flight).\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      _tcp-&gt;<span class="built_in">push</span>( [&amp;]( <span class="keyword">auto</span> x ) &#123; _datagram_adapter.<span class="built_in">write</span>( x ); &#125; );</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      <span class="built_in">return</span> ( _tcp-&gt;<span class="built_in">active</span>() ) <span class="built_in">and</span> ( <span class="keyword">not</span> _outbound_shutdown )</span><br><span class="line">             <span class="built_in">and</span> ( _tcp-&gt;<span class="built_in">outbound_writer</span>().<span class="built_in">available_capacity</span>() &gt; <span class="number">0</span> );</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      _tcp-&gt;<span class="built_in">outbound_writer</span>().<span class="built_in">close</span>();</span><br><span class="line">      _outbound_shutdown = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      std::cerr &lt;&lt; <span class="string">&quot;DEBUG: minnow outbound stream had error.\n&quot;</span>;</span><br><span class="line">      _tcp-&gt;<span class="built_in">outbound_writer</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    &#125; );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rule 3: read from inbound buffer into pipe</span></span><br><span class="line">  _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">    <span class="string">&quot;read bytes from inbound stream&quot;</span>,</span><br><span class="line">    _thread_data,</span><br><span class="line">    Direction::Out,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      Reader&amp; inbound = _tcp-&gt;<span class="built_in">inbound_reader</span>();</span><br><span class="line">      <span class="comment">// Write from the inbound_stream into</span></span><br><span class="line">      <span class="comment">// the pipe, handling the possibility of a partial</span></span><br><span class="line">      <span class="comment">// write (i.e., only pop what was actually written).</span></span><br><span class="line">      <span class="keyword">if</span> ( inbound.<span class="built_in">bytes_buffered</span>() ) &#123;</span><br><span class="line">        <span class="type">const</span> std::string_view buffer = inbound.<span class="built_in">peek</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> bytes_written = _thread_data.<span class="built_in">write</span>( buffer );</span><br><span class="line">        inbound.<span class="built_in">pop</span>( bytes_written );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( inbound.<span class="built_in">is_finished</span>() <span class="keyword">or</span> inbound.<span class="built_in">has_error</span>() ) &#123;</span><br><span class="line">        _thread_data.<span class="built_in">shutdown</span>( SHUT_WR );</span><br><span class="line">        _inbound_shutdown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// debugging output:</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;DEBUG: minnow inbound stream from &quot;</span> &lt;&lt; _datagram_adapter.<span class="built_in">config</span>().destination.<span class="built_in">to_string</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; finished &quot;</span> &lt;&lt; ( inbound.<span class="built_in">has_error</span>() ? <span class="string">&quot;uncleanly.\n&quot;</span> : <span class="string">&quot;cleanly.\n&quot;</span> );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      <span class="keyword">return</span> _tcp-&gt;<span class="built_in">inbound_reader</span>().<span class="built_in">bytes_buffered</span>()</span><br><span class="line">             <span class="built_in">or</span> ( ( _tcp-&gt;<span class="built_in">inbound_reader</span>().<span class="built_in">is_finished</span>() <span class="keyword">or</span> _tcp-&gt;<span class="built_in">inbound_reader</span>().<span class="built_in">has_error</span>() )</span><br><span class="line">                  <span class="keyword">and</span> <span class="keyword">not</span> _inbound_shutdown );</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123;&#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      std::cerr &lt;&lt; <span class="string">&quot;DEBUG: minnow inbound stream had error.\n&quot;</span>;</span><br><span class="line">      _tcp-&gt;<span class="built_in">inbound_reader</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><ul>
<li><p><code>connect</code>事件是向TCP对端写数据(SYN包)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;TCPDatagramAdapter AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPMinnowSocket&lt;AdaptT&gt;::<span class="built_in">connect</span>( <span class="type">const</span> TCPConfig&amp; c_tcp, <span class="type">const</span> FdAdapterConfig&amp; c_ad )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( _tcp ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>( <span class="string">&quot;connect() with TCPConnection already initialized&quot;</span> );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _initialize_TCP( c_tcp );</span><br><span class="line"></span><br><span class="line">  _datagram_adapter.<span class="built_in">config_mut</span>() = c_ad;</span><br><span class="line"></span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;DEBUG: minnow connecting to &quot;</span> &lt;&lt; c_ad.destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;...\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">not</span> _tcp.<span class="built_in">has_value</span>() ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>( <span class="string">&quot;TCPPeer not successfully initialized&quot;</span> );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _tcp-&gt;<span class="built_in">push</span>( [&amp;]( <span class="keyword">auto</span> x ) &#123; _datagram_adapter.<span class="built_in">write</span>( x ); &#125; );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( _tcp-&gt;<span class="built_in">sender</span>().<span class="built_in">sequence_numbers_in_flight</span>() != <span class="number">1</span> ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>( <span class="string">&quot;After TCPConnection::connect(), expected sequence_numbers_in_flight() == 1&quot;</span> );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _tcp_loop( [&amp;] &#123; <span class="keyword">return</span> _tcp-&gt;<span class="built_in">sender</span>().<span class="built_in">sequence_numbers_in_flight</span>() == <span class="number">1</span>; &#125; );</span><br><span class="line">  <span class="keyword">if</span> ( _tcp-&gt;<span class="built_in">inbound_reader</span>().<span class="built_in">has_error</span>() ) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;DEBUG: minnow error on connecting to &quot;</span> &lt;&lt; c_ad.destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;DEBUG: minnow successfully connected to &quot;</span> &lt;&lt; c_ad.destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _tcp_thread = std::<span class="built_in">thread</span>( &amp;TCPMinnowSocket::_tcp_main, <span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="listen-and-accept"><a href="#listen-and-accept" class="headerlink" title="listen_and_accept"></a>listen_and_accept</h3><ul>
<li><p><code>listen_and_accept</code>监听对端是否回复ack</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;TCPDatagramAdapter AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPMinnowSocket&lt;AdaptT&gt;::<span class="built_in">listen_and_accept</span>( <span class="type">const</span> TCPConfig&amp; c_tcp, <span class="type">const</span> FdAdapterConfig&amp; c_ad )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( _tcp ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>( <span class="string">&quot;listen_and_accept() with TCPConnection already initialized&quot;</span> );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _initialize_TCP( c_tcp );</span><br><span class="line"></span><br><span class="line">  _datagram_adapter.<span class="built_in">config_mut</span>() = c_ad;</span><br><span class="line">  _datagram_adapter.<span class="built_in">set_listening</span>( <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;DEBUG: minnow listening for incoming connection...\n&quot;</span>;</span><br><span class="line">  _tcp_loop( [&amp;] &#123; <span class="built_in">return</span> ( <span class="keyword">not</span> _tcp-&gt;<span class="built_in">has_ackno</span>() ) <span class="built_in">or</span> ( _tcp-&gt;<span class="built_in">sender</span>().<span class="built_in">sequence_numbers_in_flight</span>() ); &#125; );</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;DEBUG: minnow new connection from &quot;</span> &lt;&lt; _datagram_adapter.<span class="built_in">config</span>().destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  _tcp_thread = std::<span class="built_in">thread</span>( &amp;TCPMinnowSocket::_tcp_main, <span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="执行主函数"><a href="#执行主函数" class="headerlink" title="执行主函数"></a>执行主函数</h3><ul>
<li><p>一直循环，真正结束的函数在<code>_tcp_loop</code></p>
</li>
<li><p><code>_tcp_loop</code>结束在poll等待事件结束</p>
<ul>
<li>出错</li>
<li>TCP连接的fd关闭</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;TCPDatagramAdapter AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPMinnowSocket&lt;AdaptT&gt;::_tcp_main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">not</span> _tcp.<span class="built_in">has_value</span>() ) &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>( <span class="string">&quot;no TCP&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    _tcp_loop( [] &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; );</span><br><span class="line">    <span class="built_in">shutdown</span>( SHUT_RDWR );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">not</span> _tcp.<span class="built_in">value</span>().<span class="built_in">active</span>() ) &#123;</span><br><span class="line">      std::cerr &lt;&lt; <span class="string">&quot;DEBUG: minnow TCP connection finished &quot;</span></span><br><span class="line">                &lt;&lt; ( _tcp-&gt;<span class="built_in">inbound_reader</span>().<span class="built_in">has_error</span>() ? <span class="string">&quot;uncleanly.\n&quot;</span> : <span class="string">&quot;cleanly.\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    _tcp.<span class="built_in">reset</span>();</span><br><span class="line">  &#125; <span class="built_in">catch</span> ( <span class="type">const</span> std::exception&amp; e ) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Exception in TCPConnection runner thread: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] condition is a function returning true if loop should continue</span></span><br><span class="line"><span class="keyword">template</span>&lt;TCPDatagramAdapter AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPMinnowSocket&lt;AdaptT&gt;::_tcp_loop( <span class="type">const</span> std::function&lt;<span class="built_in">bool</span>()&gt;&amp; condition )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">auto</span> base_time = <span class="built_in">timestamp_ms</span>();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="built_in">condition</span>() ) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = _eventloop.<span class="built_in">wait_next_event</span>( TCP_TICK_MS );</span><br><span class="line">    <span class="keyword">if</span> ( ret == EventLoop::Result::Exit <span class="keyword">or</span> _abort ) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">not</span> _tcp.<span class="built_in">has_value</span>() ) &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>( <span class="string">&quot;_tcp_loop entered before TCPPeer initialized&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( _tcp.<span class="built_in">value</span>().<span class="built_in">active</span>() ) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> next_time = <span class="built_in">timestamp_ms</span>();</span><br><span class="line">      _tcp.<span class="built_in">value</span>().<span class="built_in">tick</span>( next_time - base_time, [&amp;]( <span class="keyword">auto</span> x ) &#123; _datagram_adapter.<span class="built_in">write</span>( x ); &#125; );</span><br><span class="line">      _datagram_adapter.<span class="built_in">tick</span>( next_time - base_time );</span><br><span class="line">      base_time = next_time;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TCPPeer"><a href="#TCPPeer" class="headerlink" title="TCPPeer"></a>TCPPeer</h2><ul>
<li>接收TCPMessage，然后向对端发送消息</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPPeer</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">make_send</span><span class="params">( <span class="type">const</span> <span class="keyword">auto</span>&amp; transmit )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [&amp;]( <span class="type">const</span> TCPSenderMessage&amp; x ) &#123; <span class="built_in">send</span>( x, transmit ); &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">( TCPMessage msg, <span class="type">const</span> TransmitFunction&amp; transmit )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">not</span> <span class="built_in">active</span>() ) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record time in case this peer has to linger after streams finish.</span></span><br><span class="line">    time_of_last_receipt_ = cumulative_time_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If SenderMessage occupies a sequence number, make sure to reply.</span></span><br><span class="line">    need_send_ |= ( msg.sender.<span class="built_in">sequence_length</span>() &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If SenderMessage is a &quot;keep-alive&quot; (with intentionally invalid seqno), make sure to reply.</span></span><br><span class="line">    <span class="comment">// (N.B. orthodox TCP rules require a reply on any unacceptable segment.)</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> our_ackno = receiver_.<span class="built_in">send</span>().ackno;</span><br><span class="line">    need_send_ |= ( our_ackno.<span class="built_in">has_value</span>() <span class="keyword">and</span> msg.sender.seqno + <span class="number">1</span> == our_ackno.<span class="built_in">value</span>() );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the inbound stream finish before the outbound stream? If so, no need to linger after streams finish.</span></span><br><span class="line">    <span class="keyword">if</span> ( receiver_.<span class="built_in">writer</span>().<span class="built_in">is_closed</span>() <span class="keyword">and</span> <span class="keyword">not</span> sender_.<span class="built_in">reader</span>().<span class="built_in">is_finished</span>() ) &#123;</span><br><span class="line">      linger_after_streams_finish_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give incoming TCPSenderMessage to receiver.</span></span><br><span class="line">    receiver_.<span class="built_in">receive</span>( std::<span class="built_in">move</span>( msg.sender ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give incoming TCPReceiverMessage to sender.</span></span><br><span class="line">    sender_.<span class="built_in">receive</span>( msg.receiver );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send reply if needed.</span></span><br><span class="line">    <span class="keyword">if</span> ( need_send_ ) &#123;</span><br><span class="line">      <span class="built_in">send</span>( sender_.<span class="built_in">make_empty_message</span>(), transmit );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">( <span class="type">const</span> TCPSenderMessage&amp; sender_message, <span class="type">const</span> TransmitFunction&amp; transmit )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    TCPMessage msg &#123; sender_message, receiver_.<span class="built_in">send</span>() &#125;;</span><br><span class="line">    <span class="built_in">transmit</span>( std::<span class="built_in">move</span>( msg ) );</span><br><span class="line">    need_send_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="测试端"><a href="#测试端" class="headerlink" title="测试端"></a>测试端</h2><ul>
<li><p><code> bidirectional_stream_copy</code>触发rule1和rule2；触发<code>_initialize_TCP</code>的read pipe into outbound buffer；然后发送给对端数据报</p>
</li>
<li><p>触发<code>_initialize_TCP</code>的<code>receive TCP segment from network</code>，进行消息的收发</p>
<ul>
<li><p>rule1: read from stdin into outbound byte stream</p>
</li>
<li><p>rule2: read from outbound byte stream into socket</p>
</li>
<li><p>rule3: read from socket into inbound byte stream</p>
</li>
<li><p>rule4: read from inbound byte stream into stdout</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bidirectional_stream_copy</span><span class="params">( Socket&amp; socket, string_view peer_name )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> buffer_size = <span class="number">1048576</span>;</span><br><span class="line"></span><br><span class="line">  EventLoop _eventloop &#123;&#125;;</span><br><span class="line">  FileDescriptor _input &#123; STDIN_FILENO &#125;;</span><br><span class="line">  FileDescriptor _output &#123; STDOUT_FILENO &#125;;</span><br><span class="line">  ByteStream _outbound &#123; buffer_size &#125;;</span><br><span class="line">  ByteStream _inbound &#123; buffer_size &#125;;</span><br><span class="line">  <span class="type">bool</span> _outbound_shutdown &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">  <span class="type">bool</span> _inbound_shutdown &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">  socket.<span class="built_in">set_blocking</span>( <span class="literal">false</span> );</span><br><span class="line">  _input.<span class="built_in">set_blocking</span>( <span class="literal">false</span> );</span><br><span class="line">  _output.<span class="built_in">set_blocking</span>( <span class="literal">false</span> );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rule 1: read from stdin into outbound byte stream</span></span><br><span class="line">  _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">    <span class="string">&quot;read from stdin into outbound byte stream&quot;</span>,</span><br><span class="line">    _input,</span><br><span class="line">    Direction::In,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      string data;</span><br><span class="line">      data.<span class="built_in">resize</span>( _outbound.<span class="built_in">writer</span>().<span class="built_in">available_capacity</span>() );</span><br><span class="line">      _input.<span class="built_in">read</span>( data );</span><br><span class="line">      _outbound.<span class="built_in">writer</span>().<span class="built_in">push</span>( <span class="built_in">move</span>( data ) );</span><br><span class="line">      <span class="keyword">if</span> ( _input.<span class="built_in">eof</span>() ) &#123;</span><br><span class="line">        _outbound.<span class="built_in">writer</span>().<span class="built_in">close</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      <span class="keyword">return</span> !_outbound.<span class="built_in">has_error</span>() <span class="keyword">and</span> !_inbound.<span class="built_in">has_error</span>() <span class="built_in">and</span> ( _outbound.<span class="built_in">writer</span>().<span class="built_in">available_capacity</span>() &gt; <span class="number">0</span> )</span><br><span class="line">             <span class="keyword">and</span> !_outbound.<span class="built_in">writer</span>().<span class="built_in">is_closed</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123; _outbound.<span class="built_in">writer</span>().<span class="built_in">close</span>(); &#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;DEBUG: Outbound stream had error from source.\n&quot;</span>;</span><br><span class="line">      _outbound.<span class="built_in">set_error</span>();</span><br><span class="line">      _inbound.<span class="built_in">set_error</span>();</span><br><span class="line">    &#125; );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rule 2: read from outbound byte stream into socket</span></span><br><span class="line">  _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">    <span class="string">&quot;read from outbound byte stream into socket&quot;</span>,</span><br><span class="line">    socket,</span><br><span class="line">    Direction::Out,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      <span class="keyword">if</span> ( _outbound.<span class="built_in">reader</span>().<span class="built_in">bytes_buffered</span>() ) &#123;</span><br><span class="line">        _outbound.<span class="built_in">reader</span>().<span class="built_in">pop</span>( socket.<span class="built_in">write</span>( _outbound.<span class="built_in">reader</span>().<span class="built_in">peek</span>() ) );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( _outbound.<span class="built_in">reader</span>().<span class="built_in">is_finished</span>() ) &#123;</span><br><span class="line">        socket.<span class="built_in">shutdown</span>( SHUT_WR );</span><br><span class="line">        _outbound_shutdown = <span class="literal">true</span>;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;DEBUG: Outbound stream to &quot;</span> &lt;&lt; peer_name &lt;&lt; <span class="string">&quot; finished.\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      <span class="keyword">return</span> _outbound.<span class="built_in">reader</span>().<span class="built_in">bytes_buffered</span>() <span class="built_in">or</span> ( _outbound.<span class="built_in">reader</span>().<span class="built_in">is_finished</span>() <span class="keyword">and</span> <span class="keyword">not</span> _outbound_shutdown );</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123; _outbound.<span class="built_in">writer</span>().<span class="built_in">close</span>(); &#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;DEBUG: Outbound stream had error from destination.\n&quot;</span>;</span><br><span class="line">      _outbound.<span class="built_in">set_error</span>();</span><br><span class="line">      _inbound.<span class="built_in">set_error</span>();</span><br><span class="line">    &#125; );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rule 3: read from socket into inbound byte stream</span></span><br><span class="line">  _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">    <span class="string">&quot;read from socket into inbound byte stream&quot;</span>,</span><br><span class="line">    socket,</span><br><span class="line">    Direction::In,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      string data;</span><br><span class="line">      data.<span class="built_in">resize</span>( _inbound.<span class="built_in">writer</span>().<span class="built_in">available_capacity</span>() );</span><br><span class="line">      socket.<span class="built_in">read</span>( data );</span><br><span class="line">      _inbound.<span class="built_in">writer</span>().<span class="built_in">push</span>( <span class="built_in">move</span>( data ) );</span><br><span class="line">      <span class="keyword">if</span> ( socket.<span class="built_in">eof</span>() ) &#123;</span><br><span class="line">        _inbound.<span class="built_in">writer</span>().<span class="built_in">close</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      <span class="keyword">return</span> !_inbound.<span class="built_in">has_error</span>() <span class="keyword">and</span> !_outbound.<span class="built_in">has_error</span>() <span class="built_in">and</span> ( _inbound.<span class="built_in">writer</span>().<span class="built_in">available_capacity</span>() &gt; <span class="number">0</span> )</span><br><span class="line">             <span class="keyword">and</span> !_inbound.<span class="built_in">writer</span>().<span class="built_in">is_closed</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123; _inbound.<span class="built_in">writer</span>().<span class="built_in">close</span>(); &#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;DEBUG: Inbound stream had error from source.\n&quot;</span>;</span><br><span class="line">      _outbound.<span class="built_in">set_error</span>();</span><br><span class="line">      _inbound.<span class="built_in">set_error</span>();</span><br><span class="line">    &#125; );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rule 4: read from inbound byte stream into stdout</span></span><br><span class="line">  _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">    <span class="string">&quot;read from inbound byte stream into stdout&quot;</span>,</span><br><span class="line">    _output,</span><br><span class="line">    Direction::Out,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      <span class="keyword">if</span> ( _inbound.<span class="built_in">reader</span>().<span class="built_in">bytes_buffered</span>() ) &#123;</span><br><span class="line">        _inbound.<span class="built_in">reader</span>().<span class="built_in">pop</span>( _output.<span class="built_in">write</span>( _inbound.<span class="built_in">reader</span>().<span class="built_in">peek</span>() ) );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( _inbound.<span class="built_in">reader</span>().<span class="built_in">is_finished</span>() ) &#123;</span><br><span class="line">        _output.<span class="built_in">close</span>();</span><br><span class="line">        _inbound_shutdown = <span class="literal">true</span>;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;DEBUG: Inbound stream from &quot;</span> &lt;&lt; peer_name &lt;&lt; <span class="string">&quot; finished&quot;</span></span><br><span class="line">             &lt;&lt; ( _inbound.<span class="built_in">has_error</span>() ? <span class="string">&quot; uncleanly.\n&quot;</span> : <span class="string">&quot;.\n&quot;</span> );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      <span class="keyword">return</span> _inbound.<span class="built_in">reader</span>().<span class="built_in">bytes_buffered</span>() <span class="built_in">or</span> ( _inbound.<span class="built_in">reader</span>().<span class="built_in">is_finished</span>() <span class="keyword">and</span> <span class="keyword">not</span> _inbound_shutdown );</span><br><span class="line">    &#125;,</span><br><span class="line">    [&amp;] &#123; _inbound.<span class="built_in">writer</span>().<span class="built_in">close</span>(); &#125;,</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;DEBUG: Inbound stream had error from destination.\n&quot;</span>;</span><br><span class="line">      _outbound.<span class="built_in">set_error</span>();</span><br><span class="line">      _inbound.<span class="built_in">set_error</span>();</span><br><span class="line">    &#125; );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// loop until completion</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( EventLoop::Result::Exit == _eventloop.<span class="built_in">wait_next_event</span>( <span class="number">-1</span> ) ) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IP包发送接收的设备支持"><a href="#IP包发送接收的设备支持" class="headerlink" title="IP包发送接收的设备支持"></a>IP包发送接收的设备支持</h2><ul>
<li><p>构建可以通信的TCP，泛型Adapt需要满足write和read的约束；CS144TCPSocket注册了一个TUN（网络隧道）设备来发送和接收IP数据包。</p>
</li>
<li><p>write将我们构造的TCP包序列化后写入TUN设备</p>
</li>
<li><p>read读取IP包头，获取TCP报头和报文(<code>unwrap_tcp_in_ip</code>)</p>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> TCPDatagramAdapter = <span class="built_in">requires</span>( T a, TCPMessage seg ) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    a.<span class="built_in">write</span>( seg )</span><br><span class="line">  &#125; -&gt; std::same_as&lt;<span class="type">void</span>&gt;;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    a.<span class="built_in">read</span>()</span><br><span class="line">  &#125; -&gt; std::same_as&lt;std::optional&lt;TCPMessage&gt;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \brief A FD adapter for IPv4 datagrams read from and written to a TUN device</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPOverIPv4OverTunFdAdapter</span> : <span class="keyword">public</span> TCPOverIPv4Adapter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  TunFD _tun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//! Construct from a TunFD</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TCPOverIPv4OverTunFdAdapter</span><span class="params">( TunFD&amp;&amp; tun )</span> : _tun( std::move( tun ) ) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Attempts to read and parse an IPv4 datagram containing a TCP segment related to the current connection</span></span><br><span class="line">  <span class="function">std::optional&lt;TCPMessage&gt; <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Creates an IPv4 datagram from a TCP segment and writes it to the TUN device</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">( <span class="type">const</span> TCPMessage&amp; seg )</span> </span>&#123; _tun.<span class="built_in">write</span>( <span class="built_in">serialize</span>( <span class="built_in">wrap_tcp_in_ip</span>( seg ) ) ); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Access the underlying TUN device</span></span><br><span class="line">  <span class="keyword">explicit</span> <span class="keyword">operator</span> TunFD&amp;() &#123; <span class="keyword">return</span> _tun; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Access the underlying TUN device</span></span><br><span class="line">  <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="type">const</span> TunFD&amp;() <span class="type">const</span> &#123; <span class="keyword">return</span> _tun; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Access underlying file descriptor</span></span><br><span class="line">  <span class="function">FileDescriptor&amp; <span class="title">fd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _tun; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;TCPMessage&gt; <span class="title">TCPOverIPv4OverTunFdAdapter::read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">vector&lt;string&gt; <span class="title">strs</span><span class="params">( <span class="number">2</span> )</span></span>;</span><br><span class="line">  strs.<span class="built_in">front</span>().<span class="built_in">resize</span>( IPv4Header::LENGTH );</span><br><span class="line">  _tun.<span class="built_in">read</span>( strs );</span><br><span class="line"></span><br><span class="line">  InternetDatagram ip_dgram;</span><br><span class="line">  <span class="type">const</span> vector&lt;string&gt; buffers = &#123; strs.<span class="built_in">at</span>( <span class="number">0</span> ), strs.<span class="built_in">at</span>( <span class="number">1</span> ) &#125;;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">parse</span>( ip_dgram, buffers ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unwrap_tcp_in_ip</span>( ip_dgram );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCP实现"><a href="#TCP实现" class="headerlink" title="TCP实现"></a>TCP实现</h2><ul>
<li>一个TCP的对等端需要实现的核心数据结构和功能如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPPeer</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TCPPeer</span><span class="params">( <span class="type">const</span> TCPConfig&amp; cfg )</span> : cfg_( cfg ) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Writer&amp; <span class="title">outbound_writer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sender_.<span class="built_in">writer</span>(); &#125;</span><br><span class="line">  <span class="function">Reader&amp; <span class="title">inbound_reader</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> receiver_.<span class="built_in">reader</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Passthrough methods */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">( <span class="type">const</span> TransmitFunction&amp; transmit )</span> </span>&#123; sender_.<span class="built_in">push</span>( <span class="built_in">make_send</span>( transmit ) ); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">( TCPMessage msg, <span class="type">const</span> TransmitFunction&amp; transmit )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Testing interface</span></span><br><span class="line">  <span class="function"><span class="type">const</span> TCPReceiver&amp; <span class="title">receiver</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> receiver_; &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> TCPSender&amp; <span class="title">sender</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> sender_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  TCPConfig cfg_;</span><br><span class="line">  TCPSender sender_ &#123; ByteStream &#123; cfg_.send_capacity &#125;, cfg_.isn, cfg_.rt_timeout &#125;;</span><br><span class="line">  TCPReceiver receiver_ &#123; Reassembler &#123; ByteStream &#123; cfg_.recv_capacity &#125; &#125; &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">( <span class="type">const</span> TCPSenderMessage&amp; sender_message, <span class="type">const</span> TransmitFunction&amp; transmit )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="重要数据结构"><a href="#重要数据结构" class="headerlink" title="重要数据结构"></a>重要数据结构</h3><h4 id="Byte-Stream"><a href="#Byte-Stream" class="headerlink" title="Byte_Stream"></a>Byte_Stream</h4><ul>
<li>实现字符串的先进先出；<code>Writer</code>写入字符串，<code>Reader</code>读出任意长度的字符</li>
<li>为了性能，使用<code>std::queue&lt;std::string&gt;</code>，记录弹出字符在字符串中的索引实现<code>peek()</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer::push</span><span class="params">( string data )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="type">size_t</span> datalen = data.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">size_t</span> write_avail = Writer::<span class="built_in">available_capacity</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( Writer::<span class="built_in">is_closed</span>() || write_avail == <span class="number">0</span> || data.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( datalen &gt; write_avail ) &#123;</span><br><span class="line">    data.<span class="built_in">resize</span>( write_avail );</span><br><span class="line">  &#125;</span><br><span class="line">  pushed_ += data.<span class="built_in">size</span>();</span><br><span class="line">  buffered_ += data.<span class="built_in">size</span>();</span><br><span class="line">  data_.<span class="built_in">emplace</span>( std::<span class="built_in">move</span>( data ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string_view <span class="title">Reader::peek</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> data_.<span class="built_in">empty</span>() ? string_view &#123;&#125; : string_view &#123; data_.<span class="built_in">front</span>() &#125;.<span class="built_in">substr</span>( read_index_ );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reader::pop</span><span class="params">( <span class="type">uint64_t</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  buffered_ -= len;</span><br><span class="line">  poped_ += len;</span><br><span class="line">  <span class="keyword">while</span> ( len != <span class="number">0U</span> ) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> size = data_.<span class="built_in">front</span>().<span class="built_in">size</span>() - read_index_;</span><br><span class="line">    <span class="keyword">if</span> ( len &lt; size ) &#123;</span><br><span class="line">      read_index_ += len;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要向前移动一个string</span></span><br><span class="line">    data_.<span class="built_in">pop</span>();</span><br><span class="line">    read_index_ = <span class="number">0</span>;</span><br><span class="line">    len -= size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reassembler"><a href="#Reassembler" class="headerlink" title="Reassembler"></a>Reassembler</h4><ul>
<li>将乱序接收的字符串变为有序字节流，使用<code>map</code>进行乱序字符串的存储；重点在于处理重叠字串</li>
</ul>
<p><img src="/img/CS144/Reassembler.png"></p>
<h5 id="重叠字串的处理"><a href="#重叠字串的处理" class="headerlink" title="重叠字串的处理"></a>重叠字串的处理</h5><ul>
<li><p>找到第一个小于等于<code>pos</code>的迭代器，如果map中含有的字符串与要插入的字符串产生重叠，移除含有的字符串重叠部分，增加一个重叠部分的迭代器进行后续删除操作</p>
</li>
<li><p>先找插入与字符串末尾重叠的迭代器，防止失效</p>
</li>
<li><p>再找与<code>first_index</code>重叠的迭代器</p>
</li>
<li><p>移除[<code>lower</code>, <code>upper</code>)的迭代器，插入新的字符串</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Reassembler::split</span><span class="params">( <span class="type">uint64_t</span> pos )</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it &#123; buffer_.<span class="built_in">lower_bound</span>( pos ) &#125;;</span><br><span class="line">  <span class="keyword">if</span> ( it != buffer_.<span class="built_in">end</span>() <span class="keyword">and</span> it-&gt;first == pos ) &#123;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( it == buffer_.<span class="built_in">begin</span>() ) &#123; <span class="comment">// if buffer_.empty() then begin() == end()</span></span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="type">const</span> <span class="keyword">auto</span> pit &#123; <span class="built_in">prev</span>( it ) &#125;; pit-&gt;first + <span class="built_in">size</span>( pit-&gt;second ) &gt; pos ) &#123;</span><br><span class="line">    <span class="comment">// 构建重叠部分迭代器</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> res = buffer_.<span class="built_in">emplace_hint</span>( it, pos, pit-&gt;second.<span class="built_in">substr</span>( pos - pit-&gt;first ) );</span><br><span class="line">    pit-&gt;second.<span class="built_in">resize</span>( pos - pit-&gt;first );</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> it;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对[lower, upper)的迭代器进行视图转换，然后更新reassemble的大小</span></span><br><span class="line">ranges::for_each( ranges::<span class="built_in">subrange</span>( lower, upper ) | views::values,</span><br><span class="line">                [&amp;]( <span class="type">const</span> <span class="keyword">auto</span>&amp; str ) &#123; reassemble_len_ -= str.<span class="built_in">size</span>(); &#125; );</span><br><span class="line">reassemble_len_ += <span class="built_in">size</span>(data);</span><br><span class="line">buffer_.<span class="built_in">emplace_hint</span>(buffer_.<span class="built_in">erase</span>(lower, upper), first_index, <span class="built_in">move</span>(data));</span><br><span class="line"></span><br><span class="line">~~~c++</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reassembler::insert</span><span class="params">( <span class="type">uint64_t</span> first_index, string data, <span class="type">bool</span> is_last_substring )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> try_close = [&amp;]() <span class="keyword">noexcept</span> -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( end_idx_.<span class="built_in">has_value</span>() &amp;&amp; end_idx_.<span class="built_in">value</span>() == next_unassem_idx_ ) &#123;</span><br><span class="line">      output_.<span class="built_in">writer</span>().<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( data.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !end_idx_.<span class="built_in">has_value</span>() &amp;&amp; is_last_substring ) &#123;</span><br><span class="line">      end_idx_.<span class="built_in">emplace</span>( first_index );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">try_close</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">writer</span>().<span class="built_in">is_closed</span>() || <span class="built_in">writer</span>().<span class="built_in">available_capacity</span>() == <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> unassembled_index &#123; next_unassem_idx_ &#125;;</span><br><span class="line">  <span class="type">uint64_t</span> unacceptable_index &#123; unassembled_index + <span class="built_in">writer</span>().<span class="built_in">available_capacity</span>() &#125;;</span><br><span class="line">  <span class="comment">// 将不再[unassembled_index, unacceptable_index)的字符串进行处理</span></span><br><span class="line">  <span class="keyword">if</span> ( first_index + <span class="built_in">size</span>( data ) &lt;= unassembled_index || first_index &gt;= unacceptable_index ) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// Out of ranger</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( first_index + <span class="built_in">size</span>( data ) &gt; unacceptable_index ) &#123; <span class="comment">// Remove unacceptable bytes</span></span><br><span class="line">    data.<span class="built_in">resize</span>( unacceptable_index - first_index );</span><br><span class="line">    is_last_substring = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( first_index &lt; unassembled_index ) &#123; <span class="comment">// Remove poped/buffered bytes</span></span><br><span class="line">    data.<span class="built_in">erase</span>( <span class="number">0</span>, unassembled_index - first_index );</span><br><span class="line">    first_index = unassembled_index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !end_idx_.<span class="built_in">has_value</span>() <span class="keyword">and</span> is_last_substring ) &#123;</span><br><span class="line">    end_idx_.<span class="built_in">emplace</span>( first_index + <span class="built_in">size</span>( data ) );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对字符串进行分割</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 可以对字符串移除进行优化</span></span><br><span class="line">  <span class="keyword">auto</span> upper &#123; <span class="built_in">split</span>( first_index + <span class="built_in">size</span>( data ) ) &#125;;</span><br><span class="line">  <span class="keyword">auto</span> lower &#123; <span class="built_in">split</span>( first_index ) &#125;;</span><br><span class="line">  <span class="comment">// 对[lower, upper)的迭代器进行视图转换，然后更新reassemble的大小</span></span><br><span class="line">  ranges::for_each( ranges::<span class="built_in">subrange</span>( lower, upper ) | views::values,</span><br><span class="line">                    [&amp;]( <span class="type">const</span> <span class="keyword">auto</span>&amp; str ) &#123; reassemble_len_ -= str.<span class="built_in">size</span>(); &#125; );</span><br><span class="line">  reassemble_len_ += <span class="built_in">size</span>( data );</span><br><span class="line">  buffer_.<span class="built_in">emplace_hint</span>( buffer_.<span class="built_in">erase</span>( lower, upper ), first_index, <span class="built_in">move</span>( data ) );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向writer中写入已经排好序的报文</span></span><br><span class="line">  <span class="keyword">while</span> ( !buffer_.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; [index, packet] &#123; *buffer_.<span class="built_in">begin</span>() &#125;;</span><br><span class="line">    <span class="keyword">if</span> ( index != next_unassem_idx_ ) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reassemble_len_ -= <span class="built_in">size</span>( packet );</span><br><span class="line">    next_unassem_idx_ += <span class="built_in">size</span>( packet );</span><br><span class="line">    output_.<span class="built_in">writer</span>().<span class="built_in">push</span>( <span class="built_in">move</span>( packet ) );</span><br><span class="line">    buffer_.<span class="built_in">erase</span>( buffer_.<span class="built_in">begin</span>() );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">try_close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="TCPReceiver"><a href="#TCPReceiver" class="headerlink" title="TCPReceiver"></a>TCPReceiver</h4><ul>
<li><p>64bit转32bit ——- 32bit转64bit：要求最近且不溢出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Wrap32 <span class="title">Wrap32::wrap</span><span class="params">( <span class="type">uint64_t</span> n, Wrap32 zero_point )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> zero_point + <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;( n );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Wrap32::unwrap</span><span class="params">( Wrap32 zero_point, <span class="type">uint64_t</span> checkpoint )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> n_low32 &#123; <span class="keyword">this</span>-&gt;raw_value_ - zero_point.raw_value_ &#125;;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> c_low32 &#123; checkpoint &amp; MASK_LOW_32 &#125;;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> res &#123; ( checkpoint &amp; MASK_HIGH_32 ) | n_low32 &#125;;</span><br><span class="line">  <span class="keyword">if</span> ( res &gt;= BASE <span class="keyword">and</span> n_low32 &gt; c_low32 <span class="built_in">and</span> ( n_low32 - c_low32 ) &gt; ( BASE / <span class="number">2</span> ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> res - BASE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( res &lt; MASK_HIGH_32 <span class="keyword">and</span> c_low32 &gt; n_low32 <span class="built_in">and</span> ( c_low32 - n_low32 ) &gt; ( BASE / <span class="number">2</span> ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> res + BASE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>receive</code>方法将序列号转换为<code>payload</code>索引；<code>send</code>方法返回确认的ACK</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPReceiver::receive</span><span class="params">( TCPSenderMessage message )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">writer</span>().<span class="built_in">has_error</span>() )</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> ( message.RST ) &#123;</span><br><span class="line">    <span class="built_in">reader</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !zero_point_.<span class="built_in">has_value</span>() ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !message.SYN ) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zero_point_.<span class="built_in">emplace</span>( message.seqno );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> checkpoint &#123; <span class="built_in">writer</span>().<span class="built_in">bytes_pushed</span>() + <span class="number">1</span> <span class="comment">/* SYN */</span> &#125;; <span class="comment">// abs_seqno for expecting payload</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> absolute_seqno &#123; message.seqno.<span class="built_in">unwrap</span>( zero_point_.<span class="built_in">value</span>(), checkpoint ) &#125;;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> stream_index &#123; absolute_seqno + <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;( message.SYN ) - <span class="number">1</span> <span class="comment">/* SYN */</span> &#125;;</span><br><span class="line">  reassembler_.<span class="built_in">insert</span>( stream_index, <span class="built_in">move</span>( message.payload ), message.FIN );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TCPReceiverMessage <span class="title">TCPReceiver::send</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint16_t</span> window_size &#123; <span class="built_in">writer</span>().<span class="built_in">available_capacity</span>() &gt; UINT16_MAX</span><br><span class="line">                                 ? <span class="built_in">static_cast</span>&lt;<span class="type">uint16_t</span>&gt;( UINT16_MAX )</span><br><span class="line">                                 : <span class="built_in">static_cast</span>&lt;<span class="type">uint16_t</span>&gt;( <span class="built_in">writer</span>().<span class="built_in">available_capacity</span>() ) &#125;;</span><br><span class="line">  <span class="keyword">if</span> ( zero_point_.<span class="built_in">has_value</span>() ) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> ack_for_seqno &#123; <span class="built_in">writer</span>().<span class="built_in">bytes_pushed</span>() + <span class="number">1</span> + <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;( <span class="built_in">writer</span>().<span class="built_in">is_closed</span>() ) &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123; Wrap32::<span class="built_in">wrap</span>( ack_for_seqno, zero_point_.<span class="built_in">value</span>() ), window_size, <span class="built_in">writer</span>().<span class="built_in">has_error</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="literal">nullopt</span>, window_size, <span class="built_in">writer</span>().<span class="built_in">has_error</span>() &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="TCPSender"><a href="#TCPSender" class="headerlink" title="TCPSender"></a>TCPSender</h4><h5 id="Timer实现"><a href="#Timer实现" class="headerlink" title="Timer实现"></a>Timer实现</h5><ul>
<li>控制启动、关闭、重装 <code>RTO</code>、重置定时器；</li>
<li>使用<code>tick</code>接口完成计时；</li>
<li>按需使得 <code>RTO</code>翻倍。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">( <span class="type">uint64_t</span> initial_RTO_ms )</span> : RTO_ms_( initial_RTO_ms ) &#123;</span>&#125;</span><br><span class="line">  [[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">is_active</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> is_active_; &#125;</span><br><span class="line">  [[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">is_expired</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> is_active_ &amp;&amp; running_time_ &gt;= RTO_ms_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; running_time_ = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">exponential_back</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; RTO_ms_ *= <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">reload</span><span class="params">( <span class="type">uint64_t</span> initail_RTO_ms )</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    RTO_ms_ = initail_RTO_ms;</span><br><span class="line">    <span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    is_active_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    is_active_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> Timer&amp; <span class="title">tick</span><span class="params">( <span class="type">uint64_t</span> ticks )</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    running_time_ += is_active_ ? ticks : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">uint64_t</span> RTO_ms_;</span><br><span class="line">  <span class="type">bool</span> is_active_ &#123;&#125;;</span><br><span class="line">  <span class="type">uint64_t</span> running_time_ &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h5><ul>
<li><code>push</code>尽可能在一个窗口将<code>reader</code>缓存未发送的数据发送；<code>receive</code>确认当前跟踪的消息ack均小于传来的ack，不再跟踪消息；<code>tick</code>实现指数回退超时和重传</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::push</span><span class="params">( <span class="type">const</span> TransmitFunction&amp; transmit )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">// 尽可能多的在一个窗口发送数据</span></span><br><span class="line">  <span class="keyword">while</span> ( ( window_size_ == <span class="number">0</span> ? <span class="number">1</span> : window_size_ ) &gt; total_outstanding_ ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( FIN_sent_ )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">auto</span> message &#123; <span class="built_in">make_empty_message</span>() &#125;;</span><br><span class="line">    <span class="comment">// 标记初始发送的SYN包</span></span><br><span class="line">    <span class="keyword">if</span> ( !SYN_sent_ ) &#123;</span><br><span class="line">      message.SYN = <span class="literal">true</span>;</span><br><span class="line">      SYN_sent_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// window_size空余容量(包含该条信息的长度)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> remaining &#123; ( window_size_ == <span class="number">0</span> ? <span class="number">1</span> : window_size_ ) - total_outstanding_ &#125;;</span><br><span class="line">    <span class="comment">// 还能增加payload的长度</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> payload_len &#123; <span class="built_in">min</span>( TCPConfig::MAX_PAYLOAD_SIZE, remaining - message.<span class="built_in">sequence_length</span>() ) &#125;;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; payload &#123; message.payload &#125;;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">reader</span>().<span class="built_in">bytes_buffered</span>() != <span class="number">0U</span> &amp;&amp; payload.<span class="built_in">size</span>() &lt; payload_len ) &#123;</span><br><span class="line">      string_view view &#123; <span class="built_in">reader</span>().<span class="built_in">peek</span>() &#125;;</span><br><span class="line">      <span class="comment">// 如果当前view长度小于payload_len，需要再次读取，所以这里使用循环</span></span><br><span class="line">      view = view.<span class="built_in">substr</span>( <span class="number">0</span>, payload_len - payload.<span class="built_in">size</span>() );</span><br><span class="line">      payload += view;</span><br><span class="line">      input_.<span class="built_in">reader</span>().<span class="built_in">pop</span>( view.<span class="built_in">size</span>() );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 何时增加FIN标记</span></span><br><span class="line">    <span class="keyword">if</span> ( !FIN_sent_ &amp;&amp; remaining &gt; message.<span class="built_in">sequence_length</span>() &amp;&amp; <span class="built_in">reader</span>().<span class="built_in">is_finished</span>() ) &#123;</span><br><span class="line">      message.FIN = <span class="literal">true</span>;</span><br><span class="line">      FIN_sent_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( message.<span class="built_in">sequence_length</span>() == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传输message</span></span><br><span class="line">    <span class="built_in">transmit</span>( message );</span><br><span class="line">    <span class="keyword">if</span> ( !timer_.<span class="built_in">is_active</span>() ) &#123;</span><br><span class="line">      timer_.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    next_seqno_ += message.<span class="built_in">sequence_length</span>();</span><br><span class="line">    total_outstanding_ += message.<span class="built_in">sequence_length</span>();</span><br><span class="line">    track_messages_.<span class="built_in">push</span>( message );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::receive</span><span class="params">( <span class="type">const</span> TCPReceiverMessage&amp; msg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">// 错误处理</span></span><br><span class="line">  <span class="keyword">if</span> ( input_.<span class="built_in">has_error</span>() )</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> ( msg.RST ) &#123;</span><br><span class="line">    input_.<span class="built_in">set_error</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  window_size_ = msg.window_size;</span><br><span class="line">  <span class="keyword">if</span> ( !msg.ackno.<span class="built_in">has_value</span>() )</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> recv_ack_seqno &#123; msg.ackno-&gt;<span class="built_in">unwrap</span>( isn_, next_seqno_ ) &#125;; <span class="comment">// 接收到的ack序列号</span></span><br><span class="line">  <span class="keyword">if</span> ( recv_ack_seqno &gt; next_seqno_ )</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 超过期待序列号的包直接丢弃</span></span><br><span class="line">  <span class="type">bool</span> acked &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">  <span class="comment">// 从队列中删除已经确认的包</span></span><br><span class="line">  <span class="keyword">while</span> ( !track_messages_.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; message &#123; track_messages_.<span class="built_in">front</span>() &#125;;</span><br><span class="line">    <span class="keyword">if</span> ( ack_seqno_ + message.<span class="built_in">sequence_length</span>() &gt; recv_ack_seqno )</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">// 没有完全被确认的包丢弃</span></span><br><span class="line">    acked = <span class="literal">true</span>;</span><br><span class="line">    ack_seqno_ += message.<span class="built_in">sequence_length</span>();</span><br><span class="line">    total_outstanding_ -= message.<span class="built_in">sequence_length</span>();</span><br><span class="line">    track_messages_.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 收到ack包后，重置RTO</span></span><br><span class="line">  <span class="keyword">if</span> ( acked ) &#123;</span><br><span class="line">    total_retransmit_ = <span class="number">0</span>;</span><br><span class="line">    timer_.<span class="built_in">reload</span>( initial_RTO_ms_ );</span><br><span class="line">    track_messages_.<span class="built_in">empty</span>() ? timer_.<span class="built_in">stop</span>() : timer_.<span class="built_in">start</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">( <span class="type">uint64_t</span> ms_since_last_tick, <span class="type">const</span> TransmitFunction&amp; transmit )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">// 发送的包超时</span></span><br><span class="line">  <span class="keyword">if</span> ( timer_.<span class="built_in">tick</span>( ms_since_last_tick ).<span class="built_in">is_expired</span>() ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( track_messages_.<span class="built_in">empty</span>() )</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">transmit</span>( track_messages_.<span class="built_in">front</span>() );</span><br><span class="line">    <span class="keyword">if</span> ( window_size_ != <span class="number">0</span> ) &#123;</span><br><span class="line">      total_retransmit_ += <span class="number">1</span>;</span><br><span class="line">      timer_.<span class="built_in">exponential_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    timer_.<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://tom-jerr.github.io">LZY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://tom-jerr.github.io/2024/04/22/CS144/CS144/">http://tom-jerr.github.io/2024/04/22/CS144/CS144/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tom-jerr.github.io" target="_blank">LZY的Code生活</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/TCP/">TCP</a><a class="post-meta__tags" href="/tags/CS144/">CS144</a></div><div class="post_share"><div class="social-share" data-image="/img/work.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/23/CMU15445/BufferPool/" title=""><img class="cover" src="/img/work.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2024/04/20/perfbook/Hardware_and_its_habits/" title="Hardware and its habits"><img class="cover" src="/img/work.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hardware and its habits</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/26/TCP/TCP%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/" title="TCP半连接与全连接"><img class="cover" src="/img/work.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-26</div><div class="title">TCP半连接与全连接</div></div></a></div><div><a href="/2024/04/27/TCP/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP三次握手与四次挥手"><img class="cover" src="/img/work.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-27</div><div class="title">TCP三次握手与四次挥手</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LZY</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tom-jerr"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tom-jerr" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/2584074296@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">即将进入研究生生涯，珍惜最后的大学时光</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Minnow"><span class="toc-number">1.</span> <span class="toc-text">Minnow</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">数据格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%8C%85"><span class="toc-number">1.1.1.</span> <span class="toc-text">IP包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%8A%A5%E6%96%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">TCP报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FD%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.3.</span> <span class="toc-text">FD操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">TCP工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96TCP"><span class="toc-number">1.2.1.</span> <span class="toc-text">初始化TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#connect"><span class="toc-number">1.2.2.</span> <span class="toc-text">connect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listen-and-accept"><span class="toc-number">1.2.3.</span> <span class="toc-text">listen_and_accept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">执行主函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCPPeer"><span class="toc-number">1.3.</span> <span class="toc-text">TCPPeer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%AB%AF"><span class="toc-number">1.4.</span> <span class="toc-text">测试端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E5%8C%85%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%E7%9A%84%E8%AE%BE%E5%A4%87%E6%94%AF%E6%8C%81"><span class="toc-number">1.5.</span> <span class="toc-text">IP包发送接收的设备支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.</span> <span class="toc-text">TCP实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.1.</span> <span class="toc-text">重要数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Byte-Stream"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">Byte_Stream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reassembler"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">Reassembler</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%8F%A0%E5%AD%97%E4%B8%B2%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.6.1.2.1.</span> <span class="toc-text">重叠字串的处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCPReceiver"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">TCPReceiver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCPSender"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">TCPSender</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Timer%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.1.4.1.</span> <span class="toc-text">Timer实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.1.4.2.</span> <span class="toc-text">方法实现</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/27/linux/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/" title="Zero Copy"><img src="/img/work.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Zero Copy"/></a><div class="content"><a class="title" href="/2024/04/27/linux/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/" title="Zero Copy">Zero Copy</a><time datetime="2024-04-27T10:30:00.000Z" title="发表于 2024-04-27 18:30:00">2024-04-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/27/TCP/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP三次握手与四次挥手"><img src="/img/work.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TCP三次握手与四次挥手"/></a><div class="content"><a class="title" href="/2024/04/27/TCP/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP三次握手与四次挥手">TCP三次握手与四次挥手</a><time datetime="2024-04-27T09:55:49.434Z" title="发表于 2024-04-27 17:55:49">2024-04-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/26/TCP/TCP%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/" title="TCP半连接与全连接"><img src="/img/work.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TCP半连接与全连接"/></a><div class="content"><a class="title" href="/2024/04/26/TCP/TCP%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/" title="TCP半连接与全连接">TCP半连接与全连接</a><time datetime="2024-04-26T14:36:10.356Z" title="发表于 2024-04-26 22:36:10">2024-04-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/23/Rust/TimeSharingOS/" title="TimesharingOS"><img src="/img/work.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TimesharingOS"/></a><div class="content"><a class="title" href="/2024/04/23/Rust/TimeSharingOS/" title="TimesharingOS">TimesharingOS</a><time datetime="2024-04-23T15:09:05.623Z" title="发表于 2024-04-23 23:09:05">2024-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/23/CMU15445/Hash%20Index/" title="Hash Index -- CMU15445"><img src="/img/work.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hash Index -- CMU15445"/></a><div class="content"><a class="title" href="/2024/04/23/CMU15445/Hash%20Index/" title="Hash Index -- CMU15445">Hash Index -- CMU15445</a><time datetime="2024-04-23T14:18:32.877Z" title="发表于 2024-04-23 22:18:32">2024-04-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By LZY</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">盲僧，你发现了华点</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>