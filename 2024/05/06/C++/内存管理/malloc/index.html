<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>malloc源码解析 | LZY的Code生活</title><meta name="author" content="LZY"><meta name="copyright" content="LZY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="glibc2.35版本的malloc源码解析">
<meta property="og:type" content="article">
<meta property="og:title" content="malloc源码解析">
<meta property="og:url" content="http://tom-jerr.github.io/2024/05/06/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/malloc/index.html">
<meta property="og:site_name" content="LZY的Code生活">
<meta property="og:description" content="glibc2.35版本的malloc源码解析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tom-jerr.github.io/img/work.png">
<meta property="article:published_time" content="2024-05-06T09:17:17.088Z">
<meta property="article:modified_time" content="2024-08-02T02:00:05.238Z">
<meta property="article:author" content="LZY">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tom-jerr.github.io/img/work.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://tom-jerr.github.io/2024/05/06/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/malloc/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'malloc源码解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-02 10:00:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">80</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/work.png')"><nav id="nav"><span id="blog-info"><a href="/" title="LZY的Code生活"><span class="site-name">LZY的Code生活</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">malloc源码解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-06T09:17:17.088Z" title="发表于 2024-05-06 17:17:17">2024-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-02T02:00:05.238Z" title="更新于 2024-08-02 10:00:05">2024-08-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Knowledge/">Knowledge</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="malloc源码解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="malloc源码解析"><a href="#malloc源码解析" class="headerlink" title="malloc源码解析"></a>malloc源码解析</h1><ul>
<li><strong>glibc2.35</strong></li>
</ul>
<h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="type">size_t</span> pagesize; <span class="comment">/* Page size used when allocating the arena.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-3</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>

<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd;         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd_nextsize; <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk_nextsize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* The chunk header is two SIZE_SZ elements, but this is used widely, so</span></span><br><span class="line"><span class="comment">   we define it here for clarity later.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_HDR_SZ (2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert a chunk address to a user mem pointer without correcting</span></span><br><span class="line"><span class="comment">   the tag.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((void*)((char*)(p) + CHUNK_HDR_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert a chunk address to a user mem pointer and extract the right tag.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem_tag(p) ((void*)tag_at ((char*)(p) + CHUNK_HDR_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert a user mem pointer to a chunk address and extract the right tag.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)tag_at (((char*)(mem) - CHUNK_HDR_SZ)))</span></span><br></pre></td></tr></table></figure>

<ul>
<li>allocated chunk</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of previous chunk, <span class="function"><span class="keyword">if</span> <span class="title">unallocated</span> <span class="params">(P clear)</span>  |</span></span><br><span class="line"><span class="function">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">	    |             Size of chunk, in bytes                     |A|M|P|</span></span><br><span class="line"><span class="function">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">	    |             User data starts here...                          .</span></span><br><span class="line"><span class="function">	    .                                                               .</span></span><br><span class="line"><span class="function">	    .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span></span><br><span class="line"><span class="function">	    .                                                               |</span></span><br><span class="line"><span class="function">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">	    |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span></span><br><span class="line"><span class="function">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">	    |             Size of next chunk, in bytes                |A|0|1|</span></span><br><span class="line"><span class="function">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br></pre></td></tr></table></figure>

<ul>
<li>free chunk</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of previous chunk, <span class="function"><span class="keyword">if</span> <span class="title">unallocated</span> <span class="params">(P clear)</span>  |</span></span><br><span class="line"><span class="function">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">	    |             Size of chunk, in bytes                     |A|M|P|</span></span><br><span class="line"><span class="function">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">	    |             User data starts here...                          .</span></span><br><span class="line"><span class="function">	    .                                                               .</span></span><br><span class="line"><span class="function">	    .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span></span><br><span class="line"><span class="function">	    .                                                               |</span></span><br><span class="line"><span class="function">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">	    |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span></span><br><span class="line"><span class="function">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">	    |             Size of next chunk, in bytes                |A|0|1|</span></span><br><span class="line"><span class="function">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br></pre></td></tr></table></figure>

<h3 id="arena结构"><a href="#arena结构" class="headerlink" title="arena结构"></a>arena结构</h3><p><img src="/../../img/C++/ptmalloc1.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="malloc中的系统操作"><a href="#malloc中的系统操作" class="headerlink" title="malloc中的系统操作"></a>malloc中的系统操作</h2><h3 id="sysmalloc-mmap"><a href="#sysmalloc-mmap" class="headerlink" title="sysmalloc_mmap"></a>sysmalloc_mmap</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc_mmap</span> <span class="params">(INTERNAL_SIZE_T nb, <span class="type">size_t</span> pagesize, <span class="type">int</span> extra_flags, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对齐</span></span><br><span class="line">  <span class="keyword">if</span> (MALLOC_ALIGNMENT == CHUNK_HDR_SZ)</span><br><span class="line">    size = ALIGN_UP (nb + SIZE_SZ, pagesize);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *mm = (<span class="type">char</span> *) MMAP (<span class="number">0</span>, size,</span><br><span class="line">			    mtag_mmap_flags | PROT_READ | PROT_WRITE,</span><br><span class="line">			    extra_flags);</span><br><span class="line">  <span class="keyword">if</span> (mm == MAP_FAILED)</span><br><span class="line">    <span class="keyword">return</span> mm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">  mchunkptr p;                    <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  <span class="comment">// 如果对齐需要切掉一块内存，设置为该chunk的prev_size</span></span><br><span class="line">  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">ptrdiff_t</span> correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">      p = (mchunkptr) (mm + correction);</span><br><span class="line">      set_prev_size (p, correction);</span><br><span class="line">      set_head (p, (size - correction) | IS_MMAPPED);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      p = (mchunkptr) mm;</span><br><span class="line">      set_prev_size (p, <span class="number">0</span>);</span><br><span class="line">      set_head (p, size | IS_MMAPPED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* update statistics */</span></span><br><span class="line">  <span class="type">int</span> new = atomic_exchange_and_add (&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="type">atomic_max</span> (&amp;mp_.max_n_mmaps, new);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> sum;</span><br><span class="line">  sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">  <span class="type">atomic_max</span> (&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line"></span><br><span class="line">  check_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chunk2mem (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h3><ul>
<li>先使用sysmalloc_mmap扩展</li>
<li>扩展当前堆，如果不是main_arena，如果当前堆不够，直接新分配一个堆；如果是main_arena，先brk申请内存，失败使用mmap再申请</li>
<li>对sbrk申请的内存与之前的内存进行可用的合并<ul>
<li>处理两次sbrk不连续：如果这不是第一次进行堆扩展，则需要在<code>old_top</code>处插入两个”double fencepost”。这些”double fencepost”是人工创建的块头，用于防止与未分配的空间合并。它们被标记为已分配，但实际上是太小而无法使用的块。为了使尺寸和对齐方式正确，需要插入两个”fencepost”。然后，根据需要释放剩余的空间(_int_free)。</li>
</ul>
</li>
<li>最后，进行内存的分配</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr old_top;              <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">char</span> *old_end;                  <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> size;                      <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="type">char</span> *brk;                      <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> correction;                <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="type">char</span> *snd_brk;                  <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="type">char</span> *aligned_brk;              <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                    <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr remainder;            <span class="comment">/* remainder from allocation */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;   <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">  <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">     the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">     allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">     rather than expanding top.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="comment">// use mmap</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line">	  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *mm;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_TUNABLES</span></span><br><span class="line">      <span class="keyword">if</span> (mp_.hp_pagesize &gt; <span class="number">0</span> &amp;&amp; nb &gt;= mp_.hp_pagesize)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* There is no need to isse the THP madvise call if Huge Pages are</span></span><br><span class="line"><span class="comment">	     used directly.  */</span></span><br><span class="line">	  mm = sysmalloc_mmap (nb, mp_.hp_pagesize, mp_.hp_flags, av);</span><br><span class="line">	  <span class="keyword">if</span> (mm != MAP_FAILED)</span><br><span class="line">	    <span class="keyword">return</span> mm;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      mm = sysmalloc_mmap (nb, pagesize, <span class="number">0</span>, av);</span><br><span class="line">      <span class="keyword">if</span> (mm != MAP_FAILED)</span><br><span class="line">	<span class="keyword">return</span> mm;</span><br><span class="line">      tried_mmap = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas and mmap also failed.  */</span></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">  old_top = av-&gt;top;</span><br><span class="line">  old_size = chunksize (old_top);</span><br><span class="line">  old_end = (<span class="type">char</span> *) (chunk_at_offset (old_top, old_size));</span><br><span class="line"></span><br><span class="line">  brk = snd_brk = (<span class="type">char</span> *) (MORECORE_FAILURE); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// check...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">      heap_info *old_heap, *heap;</span><br><span class="line">      <span class="type">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">      <span class="comment">/* 根据 chunk 指针找到所属的 heap_info */</span></span><br><span class="line">      old_heap = heap_for_ptr (old_top);</span><br><span class="line">      old_heap_size = old_heap-&gt;size;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">          &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          set_head (old_top, (((<span class="type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="type">char</span> *) old_top)</span><br><span class="line">                    | PREV_INUSE);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="keyword">sizeof</span> (*heap)), mp_.top_pad)))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Use a newly allocated heap.  */</span></span><br><span class="line">          heap-&gt;ar_ptr = av;</span><br><span class="line">          heap-&gt;prev = old_heap;</span><br><span class="line">          av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">          <span class="comment">/* Set up the new top.  */</span></span><br><span class="line">          top (av) = chunk_at_offset (heap, <span class="keyword">sizeof</span> (*heap));</span><br><span class="line">          set_head (top (av), (heap-&gt;size - <span class="keyword">sizeof</span> (*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">             MALLOC_ALIGNMENT in size. */</span></span><br><span class="line">          <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">             become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">             up, too, although the chunk is marked in use. */</span></span><br><span class="line">          old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">          set_head (chunk_at_offset (old_top, old_size + CHUNK_HDR_SZ),</span><br><span class="line">		    <span class="number">0</span> | PREV_INUSE);</span><br><span class="line">          <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">              set_head (chunk_at_offset (old_top, old_size),</span><br><span class="line">			CHUNK_HDR_SZ | PREV_INUSE);</span><br><span class="line">              set_foot (chunk_at_offset (old_top, old_size), CHUNK_HDR_SZ);</span><br><span class="line">              set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">              _int_free (av, old_top, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              set_head (old_top, (old_size + CHUNK_HDR_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot (old_top, (old_size + CHUNK_HDR_SZ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* We can at least try to use to mmap memory.  If new_heap fails</span></span><br><span class="line"><span class="comment">	     it is unlikely that trying to allocate huge pages will</span></span><br><span class="line"><span class="comment">	     succeed.  */</span></span><br><span class="line">	  <span class="type">char</span> *mm = sysmalloc_mmap (nb, pagesize, <span class="number">0</span>, av);</span><br><span class="line">	  <span class="keyword">if</span> (mm != MAP_FAILED)</span><br><span class="line">	    <span class="keyword">return</span> mm;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span>     <span class="comment">/* av == main_arena */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">/* Request enough space for nb + pad + overhead */</span></span><br><span class="line">      size = nb + mp_.top_pad + MINSIZE;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If contiguous, we can subtract out existing space that we hope to</span></span><br><span class="line"><span class="comment">         combine with new space. We add it back later only if</span></span><br><span class="line"><span class="comment">         we don&#x27;t actually get contiguous space.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">        size -= old_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Round to a multiple of page size or huge page size.</span></span><br><span class="line"><span class="comment">         If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">         with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">         this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">         previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_TUNABLES &amp;&amp; defined (MADV_HUGEPAGE)</span></span><br><span class="line">      <span class="comment">/* Defined in brk.c.  */</span></span><br><span class="line">      <span class="keyword">extern</span> <span class="type">void</span> *__curbrk;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (mp_.thp_pagesize != <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">uintptr_t</span> top = ALIGN_UP ((<span class="type">uintptr_t</span>) __curbrk + size,</span><br><span class="line">				    mp_.thp_pagesize);</span><br><span class="line">	  size = top - (<span class="type">uintptr_t</span>) __curbrk;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	size = ALIGN_UP (size, GLRO(dl_pagesize));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Don&#x27;t try to call MORECORE if argument is so big as to appear</span></span><br><span class="line"><span class="comment">         negative. Note that since mmap takes size_t arg, it may succeed</span></span><br><span class="line"><span class="comment">         below even if we cannot call MORECORE.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          brk = (<span class="type">char</span> *) (MORECORE (size));</span><br><span class="line">	  <span class="keyword">if</span> (brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">	    madvise_thp (brk, size);</span><br><span class="line">          LIBC_PROBE (memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If have mmap, try using it as a backup when MORECORE fails or</span></span><br><span class="line"><span class="comment">             cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span></span><br><span class="line"><span class="comment">             address space, so sbrk cannot extend to give contiguous space, but</span></span><br><span class="line"><span class="comment">             space is available elsewhere.  Note that we ignore mmap max count</span></span><br><span class="line"><span class="comment">             and threshold limits, since the space will not be used as a</span></span><br><span class="line"><span class="comment">             segregated mmap region.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">	  <span class="type">char</span> *mbrk = MAP_FAILED;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_TUNABLES</span></span><br><span class="line">	  <span class="keyword">if</span> (mp_.hp_pagesize &gt; <span class="number">0</span>)</span><br><span class="line">	    mbrk = sysmalloc_mmap_fallback (&amp;size, nb, old_size,</span><br><span class="line">					    mp_.hp_pagesize, mp_.hp_pagesize,</span><br><span class="line">					    mp_.hp_flags, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	  <span class="keyword">if</span> (mbrk == MAP_FAILED)</span><br><span class="line">	    mbrk = sysmalloc_mmap_fallback (&amp;size, nb, old_size, pagesize,</span><br><span class="line">					    MMAP_AS_MORECORE_SIZE, <span class="number">0</span>, av);</span><br><span class="line">	  <span class="keyword">if</span> (mbrk != MAP_FAILED)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* We do not need, and cannot use, another sbrk call to find end */</span></span><br><span class="line">	      brk = mbrk;</span><br><span class="line">	      snd_brk = brk + size;</span><br><span class="line">	    &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">            mp_.sbrk_base = brk;</span><br><span class="line">          av-&gt;system_mem += size;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If MORECORE extends previous space, we can likewise extend top size.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">            set_head (old_top, (size + old_size) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">	    <span class="comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span></span><br><span class="line">	    malloc_printerr (<span class="string">&quot;break adjusted to free malloc space&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             Otherwise, make adjustments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * If the first time through or noncontiguous, we need to call sbrk</span></span><br><span class="line"><span class="comment">              just to find out where the end of memory lies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * We need to ensure that all returned chunks from malloc will meet</span></span><br><span class="line"><span class="comment">              MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * If there was an intervening foreign sbrk, we need to adjust sbrk</span></span><br><span class="line"><span class="comment">              request size to account for fact that we will not be able to</span></span><br><span class="line"><span class="comment">              combine new space with existing space in old_top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * Almost all systems internally allocate whole pages at a time, in</span></span><br><span class="line"><span class="comment">              which case we might as well use the whole last page of request.</span></span><br><span class="line"><span class="comment">              So we allocate enough more memory to hit a page boundary now,</span></span><br><span class="line"><span class="comment">              which in turn causes future contiguous calls to page-align.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              front_misalign = <span class="number">0</span>;</span><br><span class="line">              end_misalign = <span class="number">0</span>;</span><br><span class="line">              correction = <span class="number">0</span>;</span><br><span class="line">              aligned_brk = brk;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* handle contiguous cases */</span></span><br><span class="line">              <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Count foreign sbrk as system_mem.  */</span></span><br><span class="line">                  <span class="keyword">if</span> (old_size)</span><br><span class="line">                    av-&gt;system_mem += brk - old_end;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* Guarantee alignment of first new chunk made from this space */</span></span><br><span class="line"></span><br><span class="line">                  front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">                         We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">                         They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">                         prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">                         is always true after initialization.</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line"></span><br><span class="line">                      correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                      aligned_brk += correction;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     If this isn&#x27;t adjacent to existing space, then we will not</span></span><br><span class="line"><span class="comment">                     be able to merge with old_top space, so must add to 2nd request.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  correction += old_size;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* Extend the end address to hit a page boundary */</span></span><br><span class="line">                  end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);</span><br><span class="line">                  correction += (ALIGN_UP (end_misalign, pagesize)) - end_misalign;</span><br><span class="line"></span><br><span class="line">                  assert (correction &gt;= <span class="number">0</span>);</span><br><span class="line">                  snd_brk = (<span class="type">char</span> *) (MORECORE (correction));</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     If can&#x27;t allocate correction, try to at least find out current</span></span><br><span class="line"><span class="comment">                     brk.  It might be enough to proceed without failing.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                     Note that if second sbrk did NOT fail, we assume that space</span></span><br><span class="line"><span class="comment">                     is contiguous with first sbrk. This is a safe assumption unless</span></span><br><span class="line"><span class="comment">                     program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span></span><br><span class="line"><span class="comment">                     occurred between our first and second calls.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">                    &#123;</span><br><span class="line">                      correction = <span class="number">0</span>;</span><br><span class="line">                      snd_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">		  <span class="keyword">else</span></span><br><span class="line">		    madvise_thp (snd_brk, correction);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* handle non-contiguous cases */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (MALLOC_ALIGNMENT == CHUNK_HDR_SZ)</span><br><span class="line">                    <span class="comment">/* MORECORE/mmap must correctly align */</span></span><br><span class="line">                    assert (((<span class="type">unsigned</span> <span class="type">long</span>) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                      <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">                             We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">                             They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">                             prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">                             is always true after initialization.</span></span><br><span class="line"><span class="comment">                           */</span></span><br><span class="line"></span><br><span class="line">                          aligned_brk += MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* Find out current end of memory */</span></span><br><span class="line">                  <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">                    &#123;</span><br><span class="line">                      snd_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Adjust top based on results of second sbrk */</span></span><br><span class="line">              <span class="keyword">if</span> (snd_brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">                &#123;</span><br><span class="line">                  av-&gt;top = (mchunkptr) aligned_brk;</span><br><span class="line">                  set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">                  av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     If not the first time through, we either have a</span></span><br><span class="line"><span class="comment">                     gap due to foreign sbrk or a non-contiguous region.  Insert a</span></span><br><span class="line"><span class="comment">                     double fencepost at old_top to prevent consolidation with space</span></span><br><span class="line"><span class="comment">                     we don&#x27;t own. These fenceposts are artificial chunks that are</span></span><br><span class="line"><span class="comment">                     marked as inuse and are in any case too small to use.  We need</span></span><br><span class="line"><span class="comment">                     two to make sizes and alignments work out.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (old_size != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         Shrink old_top to insert fenceposts, keeping size a</span></span><br><span class="line"><span class="comment">                         multiple of MALLOC_ALIGNMENT. We know there is at least</span></span><br><span class="line"><span class="comment">                         enough space in old_top to do this.</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      old_size = (old_size - <span class="number">2</span> * CHUNK_HDR_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">                      set_head (old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         Note that the following assignments completely overwrite</span></span><br><span class="line"><span class="comment">                         old_top when old_size was previously MINSIZE.  This is</span></span><br><span class="line"><span class="comment">                         intentional. We need the fencepost, even if old_top otherwise gets</span></span><br><span class="line"><span class="comment">                         lost.</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">		      set_head (chunk_at_offset (old_top, old_size),</span><br><span class="line">				CHUNK_HDR_SZ | PREV_INUSE);</span><br><span class="line">		      set_head (chunk_at_offset (old_top,</span><br><span class="line">						 old_size + CHUNK_HDR_SZ),</span><br><span class="line">				CHUNK_HDR_SZ | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">/* If possible, release the rest. */</span></span><br><span class="line">                      <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">                        &#123;</span><br><span class="line">                          _int_free (av, old_top, <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/* if (av !=  &amp;main_arena) */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) av-&gt;system_mem &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (av-&gt;max_system_mem))</span><br><span class="line">    av-&gt;max_system_mem = av-&gt;system_mem;</span><br><span class="line">  check_malloc_state (av);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* finally, do the allocation */</span></span><br><span class="line">  p = av-&gt;top;</span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check that one of the above allocation paths succeeded */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (p, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      check_malloced_chunk (av, p, nb);</span><br><span class="line">      <span class="keyword">return</span> chunk2mem (p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* catch all failure paths */</span></span><br><span class="line">  __set_errno (ENOMEM);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="systrim"><a href="#systrim" class="headerlink" title="systrim"></a>systrim</h3><ul>
<li><p>通过释放顶部块之后的额外内存来减少内存的使用量</p>
</li>
<li><p>调用MORECORE函数释放额外的内存。忽略其返回值，再次调用MORECORE函数以获取新的堆内存结束位置。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">systrim</span> <span class="params">(<span class="type">size_t</span> pad, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> top_size;         <span class="comment">/* Amount of top-most memory */</span></span><br><span class="line">  <span class="type">long</span> extra;            <span class="comment">/* Amount to release */</span></span><br><span class="line">  <span class="type">long</span> released;         <span class="comment">/* Amount actually released */</span></span><br><span class="line">  <span class="type">char</span> *current_brk;     <span class="comment">/* address returned by pre-check sbrk call */</span></span><br><span class="line">  <span class="type">char</span> *new_brk;         <span class="comment">/* address returned by post-check sbrk call */</span></span><br><span class="line">  <span class="type">long</span> top_area;</span><br><span class="line"></span><br><span class="line">  top_size = chunksize (av-&gt;top);</span><br><span class="line"></span><br><span class="line">  top_area = top_size - MINSIZE - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (top_area &lt;= pad)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Release in pagesize units and round down to the nearest page.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_TUNABLES &amp;&amp; defined (MADV_HUGEPAGE)</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mp_.thp_pagesize != <span class="number">0</span>))</span><br><span class="line">    extra = ALIGN_DOWN (top_area - pad, mp_.thp_pagesize);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    extra = ALIGN_DOWN (top_area - pad, GLRO(dl_pagesize));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extra == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Only proceed if end of memory is where we last set it.</span></span><br><span class="line"><span class="comment">     This avoids problems if there were foreign sbrk calls.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  current_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">if</span> (current_brk == (<span class="type">char</span> *) (av-&gt;top) + top_size)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Attempt to release memory. We ignore MORECORE return value,</span></span><br><span class="line"><span class="comment">         and instead call again to find out where new end of memory is.</span></span><br><span class="line"><span class="comment">         This avoids problems if first call releases less than we asked,</span></span><br><span class="line"><span class="comment">         of if failure somehow altered brk value. (We could still</span></span><br><span class="line"><span class="comment">         encounter problems if it altered brk in some very bad way,</span></span><br><span class="line"><span class="comment">         but the only thing we can do is adjust anyway, which will cause</span></span><br><span class="line"><span class="comment">         some downstream failure.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      MORECORE (-extra);</span><br><span class="line">      new_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">      LIBC_PROBE (memory_sbrk_less, <span class="number">2</span>, new_brk, extra);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (new_brk != (<span class="type">char</span> *) MORECORE_FAILURE)</span><br><span class="line">        &#123;</span><br><span class="line">          released = (<span class="type">long</span>) (current_brk - new_brk);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (released != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* Success. Adjust top. */</span></span><br><span class="line">              av-&gt;system_mem -= released;</span><br><span class="line">              set_head (av-&gt;top, (top_size - released) | PREV_INUSE);</span><br><span class="line">              check_malloc_state (av);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="arena操作"><a href="#arena操作" class="headerlink" title="arena操作"></a>arena操作</h2><h3 id="int-new-arena"><a href="#int-new-arena" class="headerlink" title="_int_new_arena"></a>_int_new_arena</h3><ul>
<li>创建一个新的堆。并初始化内存管理信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line">_int_new_arena (<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line">  heap_info *h;</span><br><span class="line">  <span class="type">char</span> *ptr;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> misalign;</span><br><span class="line"></span><br><span class="line">  h = new_heap (size + (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT),</span><br><span class="line">                mp_.top_pad);</span><br><span class="line">  <span class="keyword">if</span> (!h)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe size is too large to fit in a single heap.  So, just try</span></span><br><span class="line"><span class="comment">         to create a minimally-sized arena and let _int_malloc() attempt</span></span><br><span class="line"><span class="comment">         to deal with the large request via mmap_chunk().  */</span></span><br><span class="line">      h = new_heap (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line">      <span class="keyword">if</span> (!h)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  a = h-&gt;ar_ptr = (mstate) (h + <span class="number">1</span>);</span><br><span class="line">  malloc_init_state (a);</span><br><span class="line">  a-&gt;attached_threads = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/*a-&gt;next = NULL;*/</span></span><br><span class="line">  a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the top chunk, with proper alignment. */</span></span><br><span class="line">  ptr = (<span class="type">char</span> *) (a + <span class="number">1</span>);</span><br><span class="line">  misalign = (<span class="type">unsigned</span> <span class="type">long</span>) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">  <span class="keyword">if</span> (misalign &gt; <span class="number">0</span>)</span><br><span class="line">    ptr += MALLOC_ALIGNMENT - misalign;</span><br><span class="line">  top (a) = (mchunkptr) ptr;</span><br><span class="line">  set_head (top (a), (((<span class="type">char</span> *) h + h-&gt;size) - ptr) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_arena_new, <span class="number">2</span>, a, size);</span><br><span class="line">  mstate replaced_arena = thread_arena;</span><br><span class="line">  thread_arena = a;</span><br><span class="line">  __libc_lock_init (a-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (list_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the new arena to the global list.  */</span></span><br><span class="line">  a-&gt;next = main_arena.next;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> The barrier is an attempt to synchronize with read access</span></span><br><span class="line"><span class="comment">     in reused_arena, which does not acquire list_lock while</span></span><br><span class="line"><span class="comment">     traversing the list.  */</span></span><br><span class="line">  atomic_write_barrier ();</span><br><span class="line">  main_arena.next = a;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (list_lock);</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (free_list_lock);</span><br><span class="line">  detach_arena (replaced_arena);</span><br><span class="line">  __libc_lock_unlock (free_list_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Lock this arena.  NB: Another thread may have been attached to</span></span><br><span class="line"><span class="comment">     this arena because the arena is now accessible from the</span></span><br><span class="line"><span class="comment">     main_arena.next list and could have been picked by reused_arena.</span></span><br><span class="line"><span class="comment">     This can only happen for the last arena created (before the arena</span></span><br><span class="line"><span class="comment">     limit is reached).  At this point, some arena has to be attached</span></span><br><span class="line"><span class="comment">     to two threads.  We could acquire the arena lock before list_lock</span></span><br><span class="line"><span class="comment">     to make it less likely that reused_arena picks this new arena,</span></span><br><span class="line"><span class="comment">     but this could result in a deadlock with</span></span><br><span class="line"><span class="comment">     __malloc_fork_lock_parent.  */</span></span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (a-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取arena"><a href="#获取arena" class="headerlink" title="获取arena"></a>获取arena</h3><ul>
<li>free-list是一个arena全局链表</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">arena_get2</span> <span class="params">(<span class="type">size_t</span> size, mstate avoid_arena)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">size_t</span> narenas_limit;</span><br><span class="line"></span><br><span class="line">  a = get_free_list ();</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">      <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>)</span><br><span class="line">            narenas_limit = mp_.arena_max;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="type">int</span> n = __get_nprocs_sched ();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (n);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/* We have no information about the system.  Assume two</span></span><br><span class="line"><span class="comment">                   cores.  */</span></span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    repeat:;</span><br><span class="line">      <span class="type">size_t</span> n = narenas;</span><br><span class="line">      <span class="comment">/* NB: the following depends on the fact that (size_t)0 - 1 is a</span></span><br><span class="line"><span class="comment">         very large number and that the underflow is OK.  If arena_max</span></span><br><span class="line"><span class="comment">         is set the value of arena_test is irrelevant.  If arena_test</span></span><br><span class="line"><span class="comment">         is set but narenas is not yet larger or equal to arena_test</span></span><br><span class="line"><span class="comment">         narenas_limit is 0.  There is no possibility for narenas to</span></span><br><span class="line"><span class="comment">         be too big for the test to always fail since there is not</span></span><br><span class="line"><span class="comment">         enough address space to create that many arenas.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (n &lt;= narenas_limit - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + <span class="number">1</span>, n))</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">          a = _int_new_arena (size);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (a == <span class="literal">NULL</span>))</span><br><span class="line">            catomic_decrement (&amp;narenas);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        a = reused_arena (avoid_arena);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we don&#x27;t have the main arena, then maybe the failure is due to running</span></span><br><span class="line"><span class="comment">   out of mmapped areas, so we can try allocating on the main arena.</span></span><br><span class="line"><span class="comment">   Otherwise, it is likely that sbrk() has failed and there is still a chance</span></span><br><span class="line"><span class="comment">   to mmap(), so try one of the other arenas.  */</span></span><br><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">arena_get_retry</span> <span class="params">(mstate ar_ptr, <span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (memory_arena_retry, <span class="number">2</span>, bytes, ar_ptr);</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">      ar_ptr = &amp;main_arena;</span><br><span class="line">      __libc_lock_lock (ar_ptr-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">      ar_ptr = arena_get2 (bytes, ar_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ar_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="heap-trim"><a href="#heap-trim" class="headerlink" title="heap_trim"></a>heap_trim</h3><ol>
<li>计算需要释放的额外内存大小（extra），以页大小为单位，并向下对齐到最近的页边界。</li>
<li>如果额外内存大小为0，则无需进行修剪，返回状态值0表示修剪操作失败。</li>
<li>检查当前堆内存的结束位置是否与上一次设置的结束位置相同。这是为了避免在修剪之前存在<strong>外部的sbrk调用</strong>导致堆内存位置发生变化。</li>
</ol>
<ul>
<li>如果可以重新映射堆空间，则使用MMAP函数将额外的堆空间映射为不可访问的内存页。</li>
<li>如果无法重新映射堆空间，则使用__madvise函数将额外的堆空间标记为不需要的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Shrink a heap.  */</span></span><br><span class="line"><span class="comment">// 将多余内存映射为不可访问的内存页</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">shrink_heap</span> <span class="params">(heap_info *h, <span class="type">long</span> diff)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line"></span><br><span class="line">  new_size = (<span class="type">long</span>) h-&gt;size - diff;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; (<span class="type">long</span>) <span class="keyword">sizeof</span> (*h))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to re-map the extra heap space freshly to save memory, and make it</span></span><br><span class="line"><span class="comment">     inaccessible.  See malloc-sysdep.h to know when this is true.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (check_may_shrink_heap ()))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">char</span> *) MMAP ((<span class="type">char</span> *) h + new_size, diff, PROT_NONE,</span><br><span class="line">                         MAP_FIXED) == (<span class="type">char</span> *) MAP_FAILED)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">      h-&gt;mprotect_size = new_size;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __madvise ((<span class="type">char</span> *) h + new_size, diff, MADV_DONTNEED);</span><br><span class="line">  <span class="comment">/*fprintf(stderr, &quot;shrink %p %08lx\n&quot;, h, new_size);*/</span></span><br><span class="line"></span><br><span class="line">  h-&gt;size = new_size;</span><br><span class="line">  LIBC_PROBE (memory_heap_less, <span class="number">2</span>, h, h-&gt;size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a heap. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">heap_trim</span> <span class="params">(heap_info *heap, <span class="type">size_t</span> pad)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr = heap-&gt;ar_ptr;</span><br><span class="line">  mchunkptr top_chunk = top (ar_ptr), p;</span><br><span class="line">  heap_info *prev_heap;</span><br><span class="line">  <span class="type">long</span> new_size, top_size, top_area, extra, prev_size, misalign;</span><br><span class="line">  <span class="type">size_t</span> max_size = heap_max_size ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Can this heap go away completely? */</span></span><br><span class="line">  <span class="keyword">while</span> (top_chunk == chunk_at_offset (heap, <span class="keyword">sizeof</span> (*heap)))</span><br><span class="line">    &#123;</span><br><span class="line">      prev_heap = heap-&gt;prev;</span><br><span class="line">      prev_size = prev_heap-&gt;size - (MINSIZE - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">      p = chunk_at_offset (prev_heap, prev_size);</span><br><span class="line">      <span class="comment">/* fencepost must be properly aligned.  */</span></span><br><span class="line">      misalign = ((<span class="type">long</span>) p) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">      p = chunk_at_offset (prev_heap, prev_size - misalign);</span><br><span class="line">      assert (chunksize_nomask (p) == (<span class="number">0</span> | PREV_INUSE)); <span class="comment">/* must be fencepost */</span></span><br><span class="line">      p = prev_chunk (p);</span><br><span class="line">      new_size = chunksize (p) + (MINSIZE - <span class="number">2</span> * SIZE_SZ) + misalign;</span><br><span class="line">      assert (new_size &gt; <span class="number">0</span> &amp;&amp; new_size &lt; (<span class="type">long</span>) (<span class="number">2</span> * MINSIZE));</span><br><span class="line">      <span class="keyword">if</span> (!prev_inuse (p))</span><br><span class="line">        new_size += prev_size (p);</span><br><span class="line">      assert (new_size &gt; <span class="number">0</span> &amp;&amp; new_size &lt; max_size);</span><br><span class="line">      <span class="keyword">if</span> (new_size + (max_size - prev_heap-&gt;size) &lt; pad + MINSIZE</span><br><span class="line">						    + heap-&gt;pagesize)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ar_ptr-&gt;system_mem -= heap-&gt;size;</span><br><span class="line">      LIBC_PROBE (memory_heap_free, <span class="number">2</span>, heap, heap-&gt;size);</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">char</span> *) heap + max_size == aligned_heap_area)</span><br><span class="line">	aligned_heap_area = <span class="literal">NULL</span>;</span><br><span class="line">      __munmap (heap, max_size);</span><br><span class="line">      heap = prev_heap;</span><br><span class="line">      <span class="keyword">if</span> (!prev_inuse (p)) <span class="comment">/* consolidate backward */</span></span><br><span class="line">        &#123;</span><br><span class="line">          p = prev_chunk (p);</span><br><span class="line">          unlink_chunk (ar_ptr, p);</span><br><span class="line">        &#125;</span><br><span class="line">      assert (((<span class="type">unsigned</span> <span class="type">long</span>) ((<span class="type">char</span> *) p + new_size) &amp; (heap-&gt;pagesize - <span class="number">1</span>))</span><br><span class="line">	      == <span class="number">0</span>);</span><br><span class="line">      assert (((<span class="type">char</span> *) p + new_size) == ((<span class="type">char</span> *) heap + heap-&gt;size));</span><br><span class="line">      top (ar_ptr) = top_chunk = p;</span><br><span class="line">      set_head (top_chunk, new_size | PREV_INUSE);</span><br><span class="line">      <span class="comment">/*check_chunk(ar_ptr, top_chunk);*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Uses similar logic for per-thread arenas as the main arena with systrim</span></span><br><span class="line"><span class="comment">     and _int_free by preserving the top pad and rounding down to the nearest</span></span><br><span class="line"><span class="comment">     page.  */</span></span><br><span class="line">  top_size = chunksize (top_chunk);</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(top_size) &lt;</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  top_area = top_size - MINSIZE - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (top_area &lt; <span class="number">0</span> || (<span class="type">size_t</span>) top_area &lt;= pad)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Release in pagesize units and round down to the nearest page.  */</span></span><br><span class="line">  extra = ALIGN_DOWN(top_area - pad, heap-&gt;pagesize);</span><br><span class="line">  <span class="keyword">if</span> (extra == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to shrink. */</span></span><br><span class="line">  <span class="keyword">if</span> (shrink_heap (heap, extra) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ar_ptr-&gt;system_mem -= extra;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Success. Adjust top accordingly. */</span></span><br><span class="line">  set_head (top_chunk, (top_size - extra) | PREV_INUSE);</span><br><span class="line">  <span class="comment">/*check_chunk(ar_ptr, top_chunk);*/</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部执行函数"><a href="#内部执行函数" class="headerlink" title="内部执行函数"></a>内部执行函数</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h3><ul>
<li>调用<code>ptmalloc_init()</code>函数进行内存分配器的初始化。</li>
<li>单线程调用<code>_int_malloc</code>函数在主线程堆（main_arena）中分配内存块，并对返回的指针进行标记(tag_new_usable)；如果是多线程环境，调用<code>arena_get</code>函数获取一个可用的内存堆（arena）</li>
<li>调用<code>arena_get_retry</code>函数再次获取可用的内存堆，并调用<code>_int_malloc</code>函数进行分配。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">_Static_assert</span> (PTRDIFF_MAX &lt;= SIZE_MAX / <span class="number">2</span>,</span><br><span class="line">                  <span class="string">&quot;PTRDIFF_MAX is not more than half of SIZE_MAX&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!__malloc_initialized)</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  <span class="keyword">if</span> (!checked_request2size (bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = tcache_get (tc_idx);</span><br><span class="line">      <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = tag_new_usable (_int_malloc (&amp;main_arena, bytes));</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">	      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  victim = tag_new_usable (victim);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br></pre></td></tr></table></figure>

<h3 id="libc-free"><a href="#libc-free" class="headerlink" title="_libc_free"></a>_libc_free</h3><ul>
<li>将内存指针<code>mem</code>转换为对应的内存块指针<code>p</code>。</li>
<li>如果内存块是通过内存映射（mmapped）方式分配的，则调用<code>munmap_chunk</code>函数释放该内存块。<ul>
<li>如果需要，会调整动态的堆扩展和内存映射的阈值。</li>
</ul>
</li>
<li>如果内存块不是通过内存映射方式分配的，则进行以下操作：<ul>
<li>初始化线程缓存（Thread Cache，TCACHE）。</li>
<li>将内存块标记为属于库（tag_region）。</li>
<li>获取内存块所属的内存堆（arena）。</li>
<li>调用<code>_int_free</code>函数释放内存块。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Quickly check that the freed pointer matches the tag for the memory.</span></span><br><span class="line"><span class="comment">     This gives a useful double-free detection.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">char</span> *)mem;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> err = errno;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment">	 Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Mark the chunk as belonging to the library again.  */</span></span><br><span class="line">      (<span class="type">void</span>)tag_region (chunk2mem (p), memsize (p));</span><br><span class="line"></span><br><span class="line">      ar_ptr = arena_for_chunk (p);</span><br><span class="line">      _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __set_errno (err);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure>

<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><ul>
<li><p>如果此时没有arena，直接调用sysmalloc</p>
</li>
<li><p>如果chunk的大小 &lt; max_fast，在fast bins上查找适合的chunk；如果不存在，转到5</p>
<p>4、如果chunk大小 &lt; 512B，从small bins上去查找chunk，如果存在，分配结束</p>
<p>5、需要分配的是一块大的内存，或者small bins中找不到chunk：</p>
<ul>
<li>遍历fast bins，合并相邻的chunk，并链接到unsorted bin中</li>
<li>遍历unsorted bin中的chunk：</li>
<li>能够切割chunk直接分配，分配结束</li>
<li>根据chunk的空间大小将其放入small bins或是large bins中，遍历完成后，转到6</li>
</ul>
<p>6、需要分配的是一块大的内存，或者small bins和unsorted bin中都找不到合适的 chunk，且fast bins和unsorted bin中所有的chunk已清除：</p>
<ul>
<li>从large bins中查找，反向遍历链表，直到找到第一个大小大于待分配的chunk进行切割，余下放入unsorted bin，分配结束</li>
</ul>
<p>7、检索fast bins和bins没有找到合适的chunk，判断top chunk大小是否满足所需chunk的大小，从top chunk中分配</p>
<p>8、top chunk不能满足需求，需要扩大top chunk：</p>
<ul>
<li>主分区上，如果分配的内存 &lt; 分配阈值（默认128KB），使用brk()分配；如果分配的内存 &gt; 分配阈值，使用mmap分配</li>
<li>非主分区上，使用mmap来分配一块内存</li>
</ul>
</li>
</ul>
<h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h3><p>2、如果free的是空指针，返回</p>
<p>3、如果当前chunk是mmap映射区域映射的内存，调用munmap()释放内存</p>
<p>4、如果chunk与top chunk相邻，直接与top chunk合并，转到8</p>
<p>5、如果chunk的大小 &gt; max_fast，放入unsorted bin，并且检查是否有合并：</p>
<ul>
<li>a.没有合并情况则free</li>
<li>b.有合并情况并且和top chunk相邻，转到8</li>
</ul>
<p>6、如果chunk的大小 &lt; max_fast，放入fast bin，并且检查是否有合并：</p>
<ul>
<li>a.fast bin并没有改变chunk的状态，没有合并情况则free</li>
<li>b.有合并情况，转到7</li>
</ul>
<p>7、在fast bin，如果相邻chunk空闲，则将这两个chunk合并，放入unsorted bin。如果合并后的大小 &gt; 64KB，会触发进行fast bins的合并操作，fast bins中的chunk将被遍历合并，合并后的chunk会被放到unsorted bin中。合并后的chunk和top chunk相邻，则会合并到top chunk中，转到8</p>
<p>8、如果top chunk的大小 &gt; mmap收缩阈值（默认为128KB），对于主分配区，会试图归还top chunk中的一部分给操作系统</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">	    (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">	  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">	   large, because the corresponding heap might go away.  */</span></span><br><span class="line">	heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">	assert(heap-&gt;ar_ptr == av);</span><br><span class="line">	heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://tom-jerr.github.io">LZY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://tom-jerr.github.io/2024/05/06/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/malloc/">http://tom-jerr.github.io/2024/05/06/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/malloc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tom-jerr.github.io" target="_blank">LZY的Code生活</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/work.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/08/C++/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/Template/" title="Template"><img class="cover" src="/img/work.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Template</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/04/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理"><img class="cover" src="/img/work.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">内存管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/19/C++20/C++20%E5%8D%8F%E7%A8%8B/" title="C++20协程"><img class="cover" src="/img/work.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-19</div><div class="title">C++20协程</div></div></a></div><div><a href="/2024/04/09/C++20/C++%E5%86%85%E5%AD%98%E5%BA%8F/" title="C++内存序"><img class="cover" src="/img/work.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">C++内存序</div></div></a></div><div><a href="/2024/04/08/C++20/%E5%8D%8F%E7%A8%8B/" title="协程"><img class="cover" src="/img/work.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-08</div><div class="title">协程</div></div></a></div><div><a href="/2024/05/04/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理"><img class="cover" src="/img/work.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-04</div><div class="title">内存管理</div></div></a></div><div><a href="/2024/06/30/C++/new&malloc/" title="new&amp;malloc"><img class="cover" src="/img/work.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-30</div><div class="title">new&amp;malloc</div></div></a></div><div><a href="/2024/05/18/C++/%E7%8E%B0%E4%BB%A3C++/" title="现代C++"><img class="cover" src="/img/work.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-18</div><div class="title">现代C++</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LZY</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">80</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tom-jerr"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tom-jerr" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/2584074296@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">即将进入研究生生涯，珍惜最后的大学时光</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#malloc%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">malloc源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#heap"><span class="toc-number">1.1.1.</span> <span class="toc-text">heap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chunk"><span class="toc-number">1.1.2.</span> <span class="toc-text">chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arena%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">arena结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">malloc中的系统操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sysmalloc-mmap"><span class="toc-number">1.2.1.</span> <span class="toc-text">sysmalloc_mmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sysmalloc"><span class="toc-number">1.2.2.</span> <span class="toc-text">sysmalloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systrim"><span class="toc-number">1.2.3.</span> <span class="toc-text">systrim</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arena%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">arena操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#int-new-arena"><span class="toc-number">1.3.1.</span> <span class="toc-text">_int_new_arena</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96arena"><span class="toc-number">1.3.2.</span> <span class="toc-text">获取arena</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heap-trim"><span class="toc-number">1.3.3.</span> <span class="toc-text">heap_trim</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">内部执行函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-malloc"><span class="toc-number">1.4.1.</span> <span class="toc-text">_libc_malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-free"><span class="toc-number">1.4.2.</span> <span class="toc-text">_libc_free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-malloc"><span class="toc-number">1.4.3.</span> <span class="toc-text">_int_malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-free"><span class="toc-number">1.4.4.</span> <span class="toc-text">_int_free</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/31/6.s081/xv6/" title="无题"><img src="/img/work.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/10/31/6.s081/xv6/" title="无题">无题</a><time datetime="2024-10-31T02:45:44.569Z" title="发表于 2024-10-31 10:45:44">2024-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/31/CMU15445/lab/lab1_buffer_pool/" title="无题"><img src="/img/work.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/10/31/CMU15445/lab/lab1_buffer_pool/" title="无题">无题</a><time datetime="2024-10-30T16:37:18.218Z" title="发表于 2024-10-31 00:37:18">2024-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/31/CMU15445/11-Query_Execution/" title="11 Query Execution"><img src="/img/work.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="11 Query Execution"/></a><div class="content"><a class="title" href="/2024/10/31/CMU15445/11-Query_Execution/" title="11 Query Execution">11 Query Execution</a><time datetime="2024-10-30T16:00:00.000Z" title="发表于 2024-10-31 00:00:00">2024-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/31/CMU15445/12-Query_Plan&amp;Optimization/" title="12 Query Planning and Optimization"><img src="/img/work.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="12 Query Planning and Optimization"/></a><div class="content"><a class="title" href="/2024/10/31/CMU15445/12-Query_Plan&amp;Optimization/" title="12 Query Planning and Optimization">12 Query Planning and Optimization</a><time datetime="2024-10-30T16:00:00.000Z" title="发表于 2024-10-31 00:00:00">2024-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/31/CMU15445/10-Join%20Algorithm/" title="10-Join Algorithm"><img src="/img/work.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="10-Join Algorithm"/></a><div class="content"><a class="title" href="/2024/10/31/CMU15445/10-Join%20Algorithm/" title="10-Join Algorithm">10-Join Algorithm</a><time datetime="2024-10-30T16:00:00.000Z" title="发表于 2024-10-31 00:00:00">2024-10-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By LZY</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">盲僧，你发现了华点</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>